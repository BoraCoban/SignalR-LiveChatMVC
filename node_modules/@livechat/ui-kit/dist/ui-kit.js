(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'react-dom'], factory) :
  (global = global || self, factory(global.UIKit = {}, global.React, global.PropTypes, global.ReactDOM));
}(this, function (exports, React, PropTypes, ReactDOM) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;
  var PropTypes__default = 'default' in PropTypes ? PropTypes['default'] : PropTypes;
  var ReactDOM__default = 'default' in ReactDOM ? ReactDOM['default'] : ReactDOM;

  function memoize(fn) {
    var cache = {};
    return function (arg) {
      if (cache[arg] === undefined) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  /* eslint-disable */
  // murmurhash2 via https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
  function murmurhash2_32_gc(str) {
    var l = str.length,
        h = l ^ l,
        i = 0,
        k;

    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }

    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }

    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return (h >>> 0).toString(36);
  }

  function stylis_min (W) {
    function M(d, c, e, h, a) {
      for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
        g = e.charCodeAt(l);
        l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

        if (0 === b + n + v + m) {
          if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
            switch (g) {
              case 32:
              case 9:
              case 59:
              case 13:
              case 10:
                break;

              default:
                f += e.charAt(l);
            }

            g = 59;
          }

          switch (g) {
            case 123:
              f = f.trim();
              q = f.charCodeAt(0);
              k = 1;

              for (t = ++l; l < B;) {
                switch (g = e.charCodeAt(l)) {
                  case 123:
                    k++;
                    break;

                  case 125:
                    k--;
                    break;

                  case 47:
                    switch (g = e.charCodeAt(l + 1)) {
                      case 42:
                      case 47:
                        a: {
                          for (u = l + 1; u < J; ++u) {
                            switch (e.charCodeAt(u)) {
                              case 47:
                                if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                  l = u + 1;
                                  break a;
                                }

                                break;

                              case 10:
                                if (47 === g) {
                                  l = u + 1;
                                  break a;
                                }

                            }
                          }

                          l = u;
                        }

                    }

                    break;

                  case 91:
                    g++;

                  case 40:
                    g++;

                  case 34:
                  case 39:
                    for (; l++ < J && e.charCodeAt(l) !== g;) {
                    }

                }

                if (0 === k) break;
                l++;
              }

              k = e.substring(t, l);
              0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

              switch (q) {
                case 64:
                  0 < r && (f = f.replace(N, ''));
                  g = f.charCodeAt(1);

                  switch (g) {
                    case 100:
                    case 109:
                    case 115:
                    case 45:
                      r = c;
                      break;

                    default:
                      r = O;
                  }

                  k = M(c, r, k, g, a + 1);
                  t = k.length;
                  0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                  if (0 < t) switch (g) {
                    case 115:
                      f = f.replace(da, ea);

                    case 100:
                    case 109:
                    case 45:
                      k = f + '{' + k + '}';
                      break;

                    case 107:
                      f = f.replace(fa, '$1 $2');
                      k = f + '{' + k + '}';
                      k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                      break;

                    default:
                      k = f + k, 112 === h && (k = (p += k, ''));
                  } else k = '';
                  break;

                default:
                  k = M(c, X(c, f, I), k, h, a + 1);
              }

              F += k;
              k = I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
              break;

            case 125:
            case 59:
              f = (0 < r ? f.replace(N, '') : f).trim();
              if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
                case 0:
                  break;

                case 64:
                  if (105 === g || 99 === g) {
                    G += f + e.charAt(l);
                    break;
                  }

                default:
                  58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
              }
              I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
          }
        }

        switch (g) {
          case 13:
          case 10:
            47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
            0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
            z = 1;
            D++;
            break;

          case 59:
          case 125:
            if (0 === b + n + v + m) {
              z++;
              break;
            }

          default:
            z++;
            y = e.charAt(l);

            switch (g) {
              case 9:
              case 32:
                if (0 === n + m + b) switch (x) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y = '';
                    break;

                  default:
                    32 !== g && (y = ' ');
                }
                break;

              case 0:
                y = '\\0';
                break;

              case 12:
                y = '\\f';
                break;

              case 11:
                y = '\\v';
                break;

              case 38:
                0 === n + b + m && (r = I = 1, y = '\f' + y);
                break;

              case 108:
                if (0 === n + b + m + E && 0 < u) switch (l - u) {
                  case 2:
                    112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                  case 8:
                    111 === K && (E = K);
                }
                break;

              case 58:
                0 === n + b + m && (u = l);
                break;

              case 44:
                0 === b + v + n + m && (r = 1, y += '\r');
                break;

              case 34:
              case 39:
                0 === b && (n = n === g ? 0 : 0 === n ? g : n);
                break;

              case 91:
                0 === n + b + v && m++;
                break;

              case 93:
                0 === n + b + v && m--;
                break;

              case 41:
                0 === n + b + m && v--;
                break;

              case 40:
                if (0 === n + b + m) {
                  if (0 === q) switch (2 * x + 3 * K) {
                    case 533:
                      break;

                    default:
                      q = 1;
                  }
                  v++;
                }

                break;

              case 64:
                0 === b + v + n + m + u + k && (k = 1);
                break;

              case 42:
              case 47:
                if (!(0 < n + m + v)) switch (b) {
                  case 0:
                    switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                      case 235:
                        b = 47;
                        break;

                      case 220:
                        t = l, b = 42;
                    }

                    break;

                  case 42:
                    47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
                }
            }

            0 === b && (f += y);
        }

        K = x;
        x = g;
        l++;
      }

      t = p.length;

      if (0 < t) {
        r = c;
        if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
        p = r.join(',') + '{' + p + '}';

        if (0 !== w * E) {
          2 !== w || L(p, 2) || (E = 0);

          switch (E) {
            case 111:
              p = p.replace(ha, ':-moz-$1') + p;
              break;

            case 112:
              p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
          }

          E = 0;
        }
      }

      return G + p + F;
    }

    function X(d, c, e) {
      var h = c.trim().split(ia);
      c = h;
      var a = h.length,
          m = d.length;

      switch (m) {
        case 0:
        case 1:
          var b = 0;

          for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
            c[b] = Z(d, c[b], e, m).trim();
          }

          break;

        default:
          var v = b = 0;

          for (c = []; b < a; ++b) {
            for (var n = 0; n < m; ++n) {
              c[v++] = Z(d[n] + ' ', h[b], e, m).trim();
            }
          }

      }

      return c;
    }

    function Z(d, c, e) {
      var h = c.charCodeAt(0);
      33 > h && (h = (c = c.trim()).charCodeAt(0));

      switch (h) {
        case 38:
          return c.replace(F, '$1' + d.trim());

        case 58:
          return d.trim() + c.replace(F, '$1' + d.trim());

        default:
          if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
      }

      return d + c;
    }

    function P(d, c, e, h) {
      var a = d + ';',
          m = 2 * c + 3 * e + 4 * h;

      if (944 === m) {
        d = a.indexOf(':', 9) + 1;
        var b = a.substring(d, a.length - 1).trim();
        b = a.substring(0, d).trim() + b + ';';
        return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
      }

      if (0 === w || 2 === w && !L(a, 1)) return a;

      switch (m) {
        case 1015:
          return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

        case 951:
          return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

        case 963:
          return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

        case 1009:
          if (100 !== a.charCodeAt(4)) break;

        case 969:
        case 942:
          return '-webkit-' + a + a;

        case 978:
          return '-webkit-' + a + '-moz-' + a + a;

        case 1019:
        case 983:
          return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

        case 883:
          if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
          if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
          break;

        case 932:
          if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
            case 103:
              return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

            case 115:
              return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

            case 98:
              return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
          }
          return '-webkit-' + a + '-ms-' + a + a;

        case 964:
          return '-webkit-' + a + '-ms-flex-' + a + a;

        case 1023:
          if (99 !== a.charCodeAt(8)) break;
          b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
          return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

        case 1005:
          return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

        case 1e3:
          b = a.substring(13).trim();
          c = b.indexOf('-') + 1;

          switch (b.charCodeAt(0) + b.charCodeAt(c)) {
            case 226:
              b = a.replace(G, 'tb');
              break;

            case 232:
              b = a.replace(G, 'tb-rl');
              break;

            case 220:
              b = a.replace(G, 'lr');
              break;

            default:
              return a;
          }

          return '-webkit-' + a + '-ms-' + b + a;

        case 1017:
          if (-1 === a.indexOf('sticky', 9)) break;

        case 975:
          c = (a = d).length - 10;
          b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

          switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
            case 203:
              if (111 > b.charCodeAt(8)) break;

            case 115:
              a = a.replace(b, '-webkit-' + b) + ';' + a;
              break;

            case 207:
            case 102:
              a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
          }

          return a + ';';

        case 938:
          if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
            case 105:
              return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

            case 115:
              return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

            default:
              return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
          }
          break;

        case 973:
        case 989:
          if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

        case 931:
        case 953:
          if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
          break;

        case 962:
          if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
      }

      return a;
    }

    function L(d, c) {
      var e = d.indexOf(1 === c ? ':' : '{'),
          h = d.substring(0, 3 !== c ? e : 10);
      e = d.substring(e + 1, d.length - 1);
      return R(2 !== c ? h : h.replace(na, '$1'), e, c);
    }

    function ea(d, c) {
      var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
      return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
    }

    function H(d, c, e, h, a, m, b, v, n, q) {
      for (var g = 0, x = c, w; g < A; ++g) {
        switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
          case void 0:
          case !1:
          case !0:
          case null:
            break;

          default:
            x = w;
        }
      }

      if (x !== c) return x;
    }

    function T(d) {
      switch (d) {
        case void 0:
        case null:
          A = S.length = 0;
          break;

        default:
          switch (d.constructor) {
            case Array:
              for (var c = 0, e = d.length; c < e; ++c) {
                T(d[c]);
              }

              break;

            case Function:
              S[A++] = d;
              break;

            case Boolean:
              Y = !!d | 0;
          }

      }

      return T;
    }

    function U(d) {
      d = d.prefix;
      void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
      return U;
    }

    function B(d, c) {
      var e = d;
      33 > e.charCodeAt(0) && (e = e.trim());
      V = e;
      e = [V];

      if (0 < A) {
        var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
        void 0 !== h && 'string' === typeof h && (c = h);
      }

      var a = M(O, e, c, 0, 0);
      0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
      V = '';
      E = 0;
      z = D = 1;
      return a;
    }

    var ca = /^\0+/g,
        N = /[\0\r\f]/g,
        aa = /: */g,
        ka = /zoo|gra/,
        ma = /([,: ])(transform)/g,
        ia = /,\r+?/g,
        F = /([\t\r\n ])*\f?&/g,
        fa = /@(k\w+)\s*(\S*)\s*/,
        Q = /::(place)/g,
        ha = /:(read-only)/g,
        G = /[svh]\w+-[tblr]{2}/,
        da = /\(\s*(.*)\s*\)/g,
        oa = /([\s\S]*?);/g,
        ba = /-self|flex-/g,
        na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
        la = /stretch|:\s*\w+\-(?:conte|avail)/,
        ja = /([^-])(image-set\()/,
        z = 1,
        D = 1,
        E = 0,
        w = 1,
        O = [],
        S = [],
        A = 0,
        R = null,
        Y = 0,
        V = '';
    B.use = T;
    B.set = U;
    void 0 !== W && U(W);
    return B;
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var stylisRuleSheet = createCommonjsModule(function (module, exports) {
  (function (factory) {
  	module['exports'] = factory();
  }(function () {

  	return function (insertRule) {
  		var delimiter = '/*|*/';
  		var needle = delimiter+'}';

  		function toSheet (block) {
  			if (block)
  				try {
  					insertRule(block + '}');
  				} catch (e) {}
  		}

  		return function ruleSheet (context, content, selectors, parents, line, column, length, ns, depth, at) {
  			switch (context) {
  				// property
  				case 1:
  					// @import
  					if (depth === 0 && content.charCodeAt(0) === 64)
  						return insertRule(content+';'), ''
  					break
  				// selector
  				case 2:
  					if (ns === 0)
  						return content + delimiter
  					break
  				// at-rule
  				case 3:
  					switch (ns) {
  						// @font-face, @page
  						case 102:
  						case 112:
  							return insertRule(selectors[0]+content), ''
  						default:
  							return content + (at === 0 ? delimiter : '')
  					}
  				case -2:
  					content.split(needle).forEach(toSheet);
  			}
  		}
  	}
  }));
  });

  var hyphenateRegex = /[A-Z]|^ms/g;
  var processStyleName = memoize(function (styleName) {
    return styleName.replace(hyphenateRegex, '-$&').toLowerCase();
  });
  var processStyleValue = function processStyleValue(key, value) {
    if (value == null || typeof value === 'boolean') {
      return '';
    }

    if (unitlessKeys[key] !== 1 && key.charCodeAt(1) !== 45 && // custom properties
    !isNaN(value) && value !== 0) {
      return value + 'px';
    }

    return value;
  };

  {
    var contentValuePattern = /(attr|calc|counters?|url)\(/;
    var contentValues = ['normal', 'none', 'counter', 'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote', 'initial', 'inherit', 'unset'];
    var oldProcessStyleValue = processStyleValue;

    processStyleValue = function processStyleValue(key, value) {
      if (key === 'content') {
        if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
          console.error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
        }
      }

      return oldProcessStyleValue(key, value);
    };
  }

  var classnames = function classnames(args) {
    var len = args.length;
    var i = 0;
    var cls = '';

    for (; i < len; i++) {
      var arg = args[i];
      if (arg == null) continue;
      var toAdd = void 0;

      switch (typeof arg) {
        case 'boolean':
          break;

        case 'function':
          {
            console.error('Passing functions to cx is deprecated and will be removed in the next major version of Emotion.\n' + 'Please call the function before passing it to cx.');
          }

          toAdd = classnames([arg()]);
          break;

        case 'object':
          {
            if (Array.isArray(arg)) {
              toAdd = classnames(arg);
            } else {
              toAdd = '';

              for (var k in arg) {
                if (arg[k] && k) {
                  toAdd && (toAdd += ' ');
                  toAdd += k;
                }
              }
            }

            break;
          }

        default:
          {
            toAdd = arg;
          }
      }

      if (toAdd) {
        cls && (cls += ' ');
        cls += toAdd;
      }
    }

    return cls;
  };
  var isBrowser = typeof document !== 'undefined';

  /*

  high performance StyleSheet for css-in-js systems

  - uses multiple style tags behind the scenes for millions of rules
  - uses `insertRule` for appending in production for *much* faster performance
  - 'polyfills' on server side

  // usage

  import StyleSheet from 'glamor/lib/sheet'
  let styleSheet = new StyleSheet()

  styleSheet.inject()
  - 'injects' the stylesheet into the page (or into memory if on server)

  styleSheet.insert('#box { border: 1px solid red; }')
  - appends a css rule into the stylesheet

  styleSheet.flush()
  - empties the stylesheet of all its contents

  */
  // $FlowFixMe
  function sheetForTag(tag) {
    if (tag.sheet) {
      // $FlowFixMe
      return tag.sheet;
    } // this weirdness brought to you by firefox


    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        // $FlowFixMe
        return document.styleSheets[i];
      }
    }
  }

  function makeStyleTag(opts) {
    var tag = document.createElement('style');
    tag.setAttribute('data-emotion', opts.key || '');

    if (opts.nonce !== undefined) {
      tag.setAttribute('nonce', opts.nonce);
    }

    tag.appendChild(document.createTextNode('')) // $FlowFixMe
    ;
    (opts.container !== undefined ? opts.container : document.head).appendChild(tag);
    return tag;
  }

  var StyleSheet =
  /*#__PURE__*/
  function () {
    function StyleSheet(options) {
      this.isSpeedy = "development" === 'production'; // the big drawback here is that the css won't be editable in devtools

      this.tags = [];
      this.ctr = 0;
      this.opts = options;
    }

    var _proto = StyleSheet.prototype;

    _proto.inject = function inject() {
      if (this.injected) {
        throw new Error('already injected!');
      }

      this.tags[0] = makeStyleTag(this.opts);
      this.injected = true;
    };

    _proto.speedy = function speedy(bool) {
      if (this.ctr !== 0) {
        // cannot change speedy mode after inserting any rule to sheet. Either call speedy(${bool}) earlier in your app, or call flush() before speedy(${bool})
        throw new Error("cannot change speedy now");
      }

      this.isSpeedy = !!bool;
    };

    _proto.insert = function insert(rule, sourceMap) {
      // this is the ultrafast version, works across browsers
      if (this.isSpeedy) {
        var tag = this.tags[this.tags.length - 1];
        var sheet = sheetForTag(tag);

        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
          {
            console.warn('illegal rule', rule); // eslint-disable-line no-console
          }
        }
      } else {
        var _tag = makeStyleTag(this.opts);

        this.tags.push(_tag);

        _tag.appendChild(document.createTextNode(rule + (sourceMap || '')));
      }

      this.ctr++;

      if (this.ctr % 65000 === 0) {
        this.tags.push(makeStyleTag(this.opts));
      }
    };

    _proto.flush = function flush() {
      // $FlowFixMe
      this.tags.forEach(function (tag) {
        return tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0; // todo - look for remnants in document.styleSheets

      this.injected = false;
    };

    return StyleSheet;
  }();

  function createEmotion(context, options) {
    if (context.__SECRET_EMOTION__ !== undefined) {
      return context.__SECRET_EMOTION__;
    }

    if (options === undefined) options = {};
    var key = options.key || 'css';

    {
      if (/[^a-z-]/.test(key)) {
        throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
      }
    }

    var current;

    function insertRule(rule) {
      current += rule;

      if (isBrowser) {
        sheet.insert(rule, currentSourceMap);
      }
    }

    var insertionPlugin = stylisRuleSheet(insertRule);
    var stylisOptions;

    if (options.prefix !== undefined) {
      stylisOptions = {
        prefix: options.prefix
      };
    }

    var caches = {
      registered: {},
      inserted: {},
      nonce: options.nonce,
      key: key
    };
    var sheet = new StyleSheet(options);

    if (isBrowser) {
      // ðŸš€
      sheet.inject();
    }

    var stylis = new stylis_min(stylisOptions);
    stylis.use(options.stylisPlugins)(insertionPlugin);
    var currentSourceMap = '';

    function handleInterpolation(interpolation, couldBeSelectorInterpolation) {
      if (interpolation == null) {
        return '';
      }

      switch (typeof interpolation) {
        case 'boolean':
          return '';

        case 'function':
          if (interpolation.__emotion_styles !== undefined) {
            var selector = interpolation.toString();

            if (selector === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
            }

            return selector;
          }

          if (this === undefined && "development" !== 'production') {
            console.error('Interpolating functions in css calls is deprecated and will be removed in the next major version of Emotion.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
          }

          return handleInterpolation.call(this, this === undefined ? interpolation() : // $FlowFixMe
          interpolation(this.mergedProps, this.context), couldBeSelectorInterpolation);

        case 'object':
          return createStringFromObject.call(this, interpolation);

        default:
          var cached = caches.registered[interpolation];
          return couldBeSelectorInterpolation === false && cached !== undefined ? cached : interpolation;
      }
    }

    var objectToStringCache = new WeakMap();

    function createStringFromObject(obj) {
      if (objectToStringCache.has(obj)) {
        // $FlowFixMe
        return objectToStringCache.get(obj);
      }

      var string = '';

      if (Array.isArray(obj)) {
        obj.forEach(function (interpolation) {
          string += handleInterpolation.call(this, interpolation, false);
        }, this);
      } else {
        Object.keys(obj).forEach(function (key) {
          if (typeof obj[key] !== 'object') {
            if (caches.registered[obj[key]] !== undefined) {
              string += key + "{" + caches.registered[obj[key]] + "}";
            } else {
              string += processStyleName(key) + ":" + processStyleValue(key, obj[key]) + ";";
            }
          } else {
            if (key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
            }

            if (Array.isArray(obj[key]) && typeof obj[key][0] === 'string' && caches.registered[obj[key][0]] === undefined) {
              obj[key].forEach(function (value) {
                string += processStyleName(key) + ":" + processStyleValue(key, value) + ";";
              });
            } else {
              string += key + "{" + handleInterpolation.call(this, obj[key], false) + "}";
            }
          }
        }, this);
      }

      objectToStringCache.set(obj, string);
      return string;
    }

    var name;
    var stylesWithLabel;
    var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;

    var createClassName = function createClassName(styles, identifierName) {
      return murmurhash2_32_gc(styles + identifierName) + identifierName;
    };

    {
      var oldCreateClassName = createClassName;
      var sourceMappingUrlPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;

      createClassName = function createClassName(styles, identifierName) {
        return oldCreateClassName(styles.replace(sourceMappingUrlPattern, function (sourceMap) {
          currentSourceMap = sourceMap;
          return '';
        }), identifierName);
      };
    }

    var createStyles = function createStyles(strings) {
      var stringMode = true;
      var styles = '';
      var identifierName = '';

      if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation.call(this, strings, false);
      } else {
        styles += strings[0];
      }

      for (var _len = arguments.length, interpolations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        interpolations[_key - 1] = arguments[_key];
      }

      interpolations.forEach(function (interpolation, i) {
        styles += handleInterpolation.call(this, interpolation, styles.charCodeAt(styles.length - 1) === 46 // .
        );

        if (stringMode === true && strings[i + 1] !== undefined) {
          styles += strings[i + 1];
        }
      }, this);
      stylesWithLabel = styles;
      styles = styles.replace(labelPattern, function (match, p1) {
        identifierName += "-" + p1;
        return '';
      });
      name = createClassName(styles, identifierName);
      return styles;
    };

    {
      var oldStylis = stylis;

      stylis = function stylis(selector, styles) {
        oldStylis(selector, styles);
        currentSourceMap = '';
      };
    }

    function insert(scope, styles) {
      if (caches.inserted[name] === undefined) {
        current = '';
        stylis(scope, styles);
        caches.inserted[name] = current;
      }
    }

    var css = function css() {
      var styles = createStyles.apply(this, arguments);
      var selector = key + "-" + name;

      if (caches.registered[selector] === undefined) {
        caches.registered[selector] = stylesWithLabel;
      }

      insert("." + selector, styles);
      return selector;
    };

    var keyframes = function keyframes() {
      var styles = createStyles.apply(this, arguments);
      var animation = "animation-" + name;
      insert('', "@keyframes " + animation + "{" + styles + "}");
      return animation;
    };

    var injectGlobal = function injectGlobal() {
      var styles = createStyles.apply(this, arguments);
      insert('', styles);
    };

    function getRegisteredStyles(registeredStyles, classNames) {
      var rawClassName = '';
      classNames.split(' ').forEach(function (className) {
        if (caches.registered[className] !== undefined) {
          registeredStyles.push(className);
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }

    function merge(className, sourceMap) {
      var registeredStyles = [];
      var rawClassName = getRegisteredStyles(registeredStyles, className);

      if (registeredStyles.length < 2) {
        return className;
      }

      return rawClassName + css(registeredStyles, sourceMap);
    }

    function cx() {
      for (var _len2 = arguments.length, classNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classNames[_key2] = arguments[_key2];
      }

      return merge(classnames(classNames));
    }

    function hydrateSingleId(id) {
      caches.inserted[id] = true;
    }

    function hydrate(ids) {
      ids.forEach(hydrateSingleId);
    }

    function flush() {
      if (isBrowser) {
        sheet.flush();
        sheet.inject();
      }

      caches.inserted = {};
      caches.registered = {};
    }

    if (isBrowser) {
      var chunks = document.querySelectorAll("[data-emotion-" + key + "]");
      Array.prototype.forEach.call(chunks, function (node) {
        // $FlowFixMe
        sheet.tags[0].parentNode.insertBefore(node, sheet.tags[0]); // $FlowFixMe

        node.getAttribute("data-emotion-" + key).split(' ').forEach(hydrateSingleId);
      });
    }

    var emotion = {
      flush: flush,
      hydrate: hydrate,
      cx: cx,
      merge: merge,
      getRegisteredStyles: getRegisteredStyles,
      injectGlobal: injectGlobal,
      keyframes: keyframes,
      css: css,
      sheet: sheet,
      caches: caches
    };
    context.__SECRET_EMOTION__ = emotion;
    return emotion;
  }

  var stylisCustomProperties = createCommonjsModule(function (module, exports) {
  (function (factory) {
  	module['exports'] = factory();
  }(function () {

  	var store = null;

  	function replace (match, group) {
  		return store[group] || match
  	}

  	return function (context, content, selectors, parents, line, column, length) {
  		switch (context) {
  			case -1: {
  				// create store
  				store = {};
  				break
  			}
  			case -2: {
  				// destroy store
  				store = null;
  				break
  			}
  			case 1: {
  				if (content.charCodeAt(0) + content.charCodeAt(1) === 90) {
  					// collect custom properties
  					var index = content.indexOf(':');
  					var name = content.substring(0, index);
  					var value = content.substring(index+1).trim();

  					return (store[name] = value, '')
  				} else if (content.indexOf('var(') > 0) {
  					// replace custom properties
  					return content.replace(/var\((.*)\)/g, replace)
  				}

  				break
  			}
  		}
  	}
  }));
  });

  var emotion = createEmotion({}, {
    key: 'lc',
    stylisPlugins: [stylisCustomProperties]
  });
  var css = emotion.css,
      cx = emotion.cx,
      injectGlobal = emotion.injectGlobal,
      keyframes = emotion.keyframes;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class)|(on[A-Z].*)|((data|aria|x)-.*))$/i;
  var index = memoize(reactPropsRegex.test.bind(reactPropsRegex));

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var channel = '__EMOTION_THEMING__';

  // https://github.com/styled-components/styled-components/blob/e05b3fe247e9d956bcde786cec376e32afb85bca/src/utils/create-broadcast.js

  var _contextTypes;
  var contextTypes = (_contextTypes = {}, _contextTypes[channel] = PropTypes__default.object, _contextTypes);

  function setTheme(theme) {
    this.setState({
      theme: theme
    });
  }
  var testPickPropsOnStringTag = index;
  var testPickPropsOnComponent = function testPickPropsOnComponent(key) {
    return key !== 'theme' && key !== 'innerRef';
  };
  var testAlwaysTrue = function testAlwaysTrue() {
    return true;
  };
  var pickAssign = function pickAssign(testFn, target) {
    var i = 2;
    var length = arguments.length;

    for (; i < length; i++) {
      var source = arguments[i];

      var _key = void 0;

      for (_key in source) {
        if (testFn(_key)) {
          target[_key] = source[_key];
        }
      }
    }

    return target;
  };

  var warnedAboutExtractStatic = false;

  function createEmotionStyled(emotion, view) {
    var _createStyled = function createStyled(tag, options) {
      {
        if (tag === undefined) {
          throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
        }
      }

      var staticClassName;
      var identifierName;
      var stableClassName;
      var shouldForwardProp;

      if (options !== undefined) {
        staticClassName = options.e;
        identifierName = options.label;
        stableClassName = options.target;
        shouldForwardProp = tag.__emotion_forwardProp && options.shouldForwardProp ? function (propName) {
          return tag.__emotion_forwardProp(propName) && // $FlowFixMe
          options.shouldForwardProp(propName);
        } : options.shouldForwardProp;
      }

      var isReal = tag.__emotion_real === tag;
      var baseTag = staticClassName === undefined ? isReal && tag.__emotion_base || tag : tag;

      if (typeof shouldForwardProp !== 'function') {
        shouldForwardProp = typeof baseTag === 'string' && baseTag.charAt(0) === baseTag.charAt(0).toLowerCase() ? testPickPropsOnStringTag : testPickPropsOnComponent;
      }

      return function () {
        var args = arguments;
        var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

        if (identifierName !== undefined) {
          styles.push("label:" + identifierName + ";");
        }

        if (staticClassName === undefined) {
          if (args[0] == null || args[0].raw === undefined) {
            styles.push.apply(styles, args);
          } else {
            styles.push(args[0][0]);
            var len = args.length;
            var i = 1;

            for (; i < len; i++) {
              styles.push(args[i], args[0][i]);
            }
          }
        } else if (!warnedAboutExtractStatic) {
          console.warn('extractStatic is deprecated and will be removed in emotion@10. We recommend disabling extractStatic or using other libraries like linaria or css-literal-loader');
          warnedAboutExtractStatic = true;
        }

        var Styled =
        /*#__PURE__*/
        function (_view$Component) {
          _inheritsLoose(Styled, _view$Component);

          function Styled() {
            return _view$Component.apply(this, arguments) || this;
          }

          var _proto = Styled.prototype;

          _proto.componentWillMount = function componentWillMount() {
            if (this.context[channel] !== undefined) {
              this.unsubscribe = this.context[channel].subscribe(setTheme.bind(this));
            }
          };

          _proto.componentWillUnmount = function componentWillUnmount() {
            if (this.unsubscribe !== undefined) {
              this.context[channel].unsubscribe(this.unsubscribe);
            }
          };

          _proto.render = function render() {
            var props = this.props,
                state = this.state;
            this.mergedProps = pickAssign(testAlwaysTrue, {}, props, {
              theme: state !== null && state.theme || props.theme || {}
            });
            var className = '';
            var classInterpolations = [];

            if (props.className) {
              if (staticClassName === undefined) {
                className += emotion.getRegisteredStyles(classInterpolations, props.className);
              } else {
                className += props.className + " ";
              }
            }

            if (staticClassName === undefined) {
              className += emotion.css.apply(this, styles.concat(classInterpolations));
            } else {
              className += staticClassName;
            }

            if (stableClassName !== undefined) {
              className += " " + stableClassName;
            }

            return view.createElement(baseTag, // $FlowFixMe
            pickAssign(shouldForwardProp, {}, props, {
              className: className,
              ref: props.innerRef
            }));
          };

          return Styled;
        }(view.Component);

        Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";

        if (tag.defaultProps !== undefined) {
          // $FlowFixMe
          Styled.defaultProps = tag.defaultProps;
        }

        Styled.contextTypes = contextTypes;
        Styled.__emotion_styles = styles;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_real = Styled;
        Styled.__emotion_forwardProp = shouldForwardProp;
        Object.defineProperty(Styled, 'toString', {
          value: function value() {
            if (stableClassName === undefined) {
              return 'NO_COMPONENT_SELECTOR';
            } // $FlowFixMe


            return "." + stableClassName;
          }
        });

        Styled.withComponent = function (nextTag, nextOptions) {
          return _createStyled(nextTag, nextOptions !== undefined ? // $FlowFixMe
          pickAssign(testAlwaysTrue, {}, options, nextOptions) : options).apply(void 0, styles);
        };

        return Styled;
      };
    };

    if (typeof Proxy !== 'undefined') {
      _createStyled = new Proxy(_createStyled, {
        get: function get(target, property) {
          switch (property) {
            // react-hot-loader tries to access this stuff
            case '__proto__':
            case 'name':
            case 'prototype':
            case 'displayName':
              {
                return target[property];
              }

            default:
              {
                throw new Error("You're trying to use the styled shorthand without babel-plugin-emotion." + ("\nPlease install and setup babel-plugin-emotion or use the function call syntax(`styled('" + property + "')` instead of `styled." + property + "`)"));
              }
          }
        }
      });
    }

    return _createStyled;
  }

  var _ref = {},
      hasOwnProperty = _ref.hasOwnProperty;
  function hasOwn(prop, obj) {
    return hasOwnProperty.call(obj, prop);
  }

  var isArray = Array.isArray;

  function isObject(obj) {
    return typeof obj === 'object' && obj !== null && !isArray(obj);
  }

  function mapValues(mapper, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      acc[key] = mapper(obj[key]);
      return acc;
    }, {});
  }

  function compact(collection) {
    return isArray(collection) ? collection.filter(function (value) {
      return value !== null && value !== undefined;
    }) : Object.keys(collection).reduce(function (result, key) {
      var value = collection[key];

      if (value !== null && value !== undefined) {
        result[key] = value;
      }

      return result;
    }, {});
  }

  function debounce(ms, fn) {
    // actual return type of setTimeout differs per platform (browser vs node)
    var timeoutId;
    return function () {
      clearTimeout(timeoutId);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      timeoutId = setTimeout.apply(void 0, [fn, ms].concat(args));
    };
  }

  // eslint-disable-next-line consistent-return
  function find(predicate, arr) {
    for (var index = 0; index < arr.length; index++) {
      var element = arr[index];

      if (predicate(element)) {
        return element;
      }
    }
  }

  function findIndex(predicate, arr) {
    for (var index = 0; index < arr.length; index++) {
      if (predicate(arr[index])) {
        return index;
      }
    }

    return -1;
  }

  // eslint-disable-next-line lodash-fp/prefer-identity
  function identity(value) {
    return value;
  }

  // previous version was written like this, but it seems that TS can't intersect function types like this? it infers (any, any) => any from this
  // type IndexerCallback<T extends { [key: string]: any }> = { [P in keyof T]: (val: T[P], key: P) => any }[keyof T]
  function forOwn(callback, obj) {
    return Object.keys(obj).forEach(function (key) {
      callback(obj[key], key);
    });
  }

  function groupKeys(mapper, obj) {
    return Object.keys(obj).reduce(function (grouped, key) {
      var groupKey = mapper(key);
      grouped[groupKey] = grouped[groupKey] || {};
      grouped[groupKey][key] = obj[key];
      return grouped;
    }, {});
  }

  function isEmpty(collection) {
    return (isArray(collection) ? collection : Object.keys(collection)).length === 0;
  }

  function mapKeys(mapper, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      acc[mapper(key)] = obj[key];
      return acc;
    }, {});
  }

  function mapValuesIndexed(iteratee, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      acc[key] = iteratee(obj[key], key);
      return acc;
    }, {});
  }

  function merge(objA, objB) {
    if (isEmpty(objB)) {
      return objA;
    }

    var result = {};
    forOwn(function (value, key) {
      if (hasOwn(key, objB)) {
        if (isObject(objA[key]) && isObject(objB[key])) {
          result[key] = merge(objA[key], objB[key]);
        } else {
          result[key] = objB[key];
        }
      } else {
        result[key] = objA[key];
      }
    }, objA);
    forOwn(function (value, key) {
      if (!hasOwn(key, result)) {
        result[key] = objB[key];
      }
    }, objB);
    return result;
  }

  function mergeAll(objs) {
    if (objs.length === 0) {
      return {};
    }

    var first = objs[0],
        rest = objs.slice(1);
    return rest.reduce(function (merged, obj) {
      return merge(merged, obj);
    }, first);
  }

  function memoizeWith(keyResolver, func) {
    var cache = {};
    return function () {
      var key = keyResolver.apply(void 0, arguments);

      if (hasOwn(key, cache)) {
        return cache[key];
      }

      var value = func.apply(void 0, arguments);
      cache[key] = value;
      return value;
    };
  }

  // TODO: technically this should accept AnyFunction but it doesn't type check currently with that for some reason
  function memoize$1(func) {
    return memoizeWith(identity, func);
  }

  function memoizeOne(fn) {
    var called = false;
    var memoized;
    var cacheKey;
    return function () {
      if (called && (arguments.length <= 0 ? undefined : arguments[0]) === cacheKey) {
        return memoized;
      }

      called = true;
      cacheKey = arguments.length <= 0 ? undefined : arguments[0];
      memoized = fn.apply(void 0, arguments);
      return memoized;
    };
  }

  function noop() {}

  function values(obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  }

  function omitByIndexed(predicate, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (!predicate(obj[key], key)) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  function once(fn) {
    var called = false;
    var result;
    return function () {
      if (called) {
        return result;
      }

      called = true;
      return result = fn.apply(void 0, arguments);
    };
  }

  function pick(props, obj) {
    return props.reduce(function (acc, prop) {
      acc[prop] = obj[prop];
      return acc;
    }, {});
  }

  function pickBy(predicate, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (predicate(obj[key])) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  function pickByIndexed(predicate, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (predicate(obj[key], key)) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  function throttle(ms, fn) {
    var lastCall = Date.now() - 2 * ms;
    var trailingId;

    var invoke = function invoke() {
      lastCall = Date.now();
      fn.apply(void 0, arguments);
    };

    return function () {
      var now = Date.now();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (now - lastCall >= ms) {
        invoke.apply(void 0, args);
        return;
      }

      clearTimeout(trailingId);
      trailingId = setTimeout.apply(void 0, [invoke, lastCall - now + ms].concat(args));
    };
  }

  var trailingWhiteSpace = /\s+$/;
  function trimEnd(str) {
    return str.replace(trailingWhiteSpace, '');
  }

  var mapCommonPropsToStyles = (function (props) {
    var styles = {};

    if (props.flexFill) {
      styles.flexGrow = 1;
      styles.maxWidth = '100%';
    }

    if (props.flexFit) {
      if (props.flexFill) {
        // eslint-disable-next-line no-console
        console.warn("Using flexFill & flexFit props together doesn't make sense.");
      }

      styles.flexGrow = 0;
    }

    if (props.noShrink) {
      styles.flexShrink = 0;
    }

    if (props.ellipsis) {
      styles.whiteSpace = 'nowrap';
      styles.overflow = 'hidden';
      styles.textOverflow = 'ellipsis';
    }

    if (props.nowrap) {
      styles.whiteSpace = 'nowrap';
    }

    if (props.preserveLines) {
      if (props.nowrap) {
        // eslint-disable-next-line no-console
        console.warn("Using nowrap & preserveLines props together doesn't make sense.");
      }

      styles.whiteSpace = 'pre-line';
    }

    if (props.textWrap) {
      var breakWord = 'break-word';
      styles.wordWrap = breakWord;
      styles.overflowWrap = breakWord;
      styles.wordBreak = breakWord;
    }

    return styles;
  });

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   * 
   */

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */

  var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var createChangeEmitter = exports.createChangeEmitter = function createChangeEmitter() {
    var currentListeners = [];
    var nextListeners = currentListeners;

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }

    function listen(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected listener to be a function.');
      }

      var isSubscribed = true;

      ensureCanMutateNextListeners();
      nextListeners.push(listener);

      return function () {
        if (!isSubscribed) {
          return;
        }

        isSubscribed = false;

        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }

    function emit() {
      currentListeners = nextListeners;
      var listeners = currentListeners;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].apply(listeners, arguments);
      }
    }

    return {
      listen: listen,
      emit: emit
    };
  };
  });

  unwrapExports(lib);
  var lib_1 = lib.createChangeEmitter;

  function symbolObservablePonyfill(root) {
  	var result;
  	var Symbol = root.Symbol;

  	if (typeof Symbol === 'function') {
  		if (Symbol.observable) {
  			result = Symbol.observable;
  		} else {
  			result = Symbol('observable');
  			Symbol.observable = result;
  		}
  	} else {
  		result = '@@observable';
  	}

  	return result;
  }

  /* global window */

  var root;

  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = symbolObservablePonyfill(root);

  var getDisplayName = function getDisplayName(Component$$1) {
    if (typeof Component$$1 === 'string') {
      return Component$$1;
    }

    if (!Component$$1) {
      return undefined;
    }

    return Component$$1.displayName || Component$$1.name || 'Component';
  };











  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };



  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var Nothing = function (_Component) {
    inherits(Nothing, _Component);

    function Nothing() {
      classCallCheck(this, Nothing);
      return possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    Nothing.prototype.render = function render() {
      return null;
    };

    return Nothing;
  }(React.Component);

  Nothing.displayName = 'Nothing';

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */
  var REACT_STATICS = {
      childContextTypes: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
  };

  var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
  };

  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

          if (objectPrototype) {
              var inheritedComponent = getPrototypeOf(sourceComponent);
              if (inheritedComponent && inheritedComponent !== objectPrototype) {
                  hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
              }
          }

          var keys = getOwnPropertyNames(sourceComponent);

          if (getOwnPropertySymbols) {
              keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }

          for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                  var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                  try { // Avoid failures from read-only properties
                      defineProperty(targetComponent, key, descriptor);
                  } catch (e) {}
              }
          }

          return targetComponent;
      }

      return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  function _inheritsLoose$2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  // https://github.com/styled-components/styled-components/blob/e05b3fe247e9d956bcde786cec376e32afb85bca/src/utils/create-broadcast.js
  var createBroadcast = function createBroadcast(initialState) {
    var listeners = {};
    var id = 0;
    var state = initialState;

    function publish(nextState) {
      state = nextState;

      for (var key in listeners) {
        // $FlowFixMe
        var listener = listeners[key];

        if (listener === undefined) {
          continue;
        }

        listener(state);
      }
    }

    function subscribe(listener) {
      var currentId = id;
      listeners[currentId] = listener;
      id += 1;
      listener(state);
      return currentId;
    }

    function unsubscribe(unsubID) {
      listeners[unsubID] = undefined;
    }

    return {
      publish: publish,
      subscribe: subscribe,
      unsubscribe: unsubscribe
    };
  };

  var channel$1 = '__EMOTION_THEMING__';

  var _contextTypes$1;
  var contextTypes$1 = (_contextTypes$1 = {}, _contextTypes$1[channel$1] = PropTypes__default.object, _contextTypes$1);

  var isPlainObject = function isPlainObject(test) {
    return Object.prototype.toString.call(test) === '[object Object]';
  };

  // Get the theme from the props, supporting both (outerTheme) => {} as well as object notation
  function getTheme(theme, outerTheme) {
    if (typeof theme === 'function') {
      var mergedTheme = theme(outerTheme);

      if (!isPlainObject(mergedTheme)) {
        throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');
      }

      return mergedTheme;
    }

    if (!isPlainObject(theme)) {
      throw new Error('[ThemeProvider] Please make your theme prop a plain object');
    }

    if (outerTheme === undefined) {
      return theme;
    }

    return _extends$1({}, outerTheme, theme);
  }

  var ThemeProvider =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose$2(ThemeProvider, _Component);

    function ThemeProvider() {
      return _Component.apply(this, arguments) || this;
    }

    var _proto = ThemeProvider.prototype;

    _proto.componentWillMount = function componentWillMount() {
      var _this = this;

      // If there is a ThemeProvider wrapper anywhere around this theme provider, merge this theme
      // with the outer theme
      if (this.context[channel$1] !== undefined) {
        this.unsubscribeToOuterId = this.context[channel$1].subscribe(function (theme) {
          _this.outerTheme = theme;

          if (_this.broadcast !== undefined) {
            _this.publish(_this.props.theme);
          }
        });
      }

      this.broadcast = createBroadcast(getTheme(this.props.theme, this.outerTheme));
    };

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[channel$1] = {
        subscribe: this.broadcast.subscribe,
        unsubscribe: this.broadcast.unsubscribe
      }, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.theme !== nextProps.theme) {
        this.publish(nextProps.theme);
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      var themeContext = this.context[channel$1];

      if (themeContext !== undefined) {
        themeContext.unsubscribe(this.unsubscribeToOuterId);
      }
    };

    _proto.publish = function publish(theme) {
      this.broadcast.publish(getTheme(theme, this.outerTheme));
    };

    _proto.render = function render() {
      if (!this.props.children) {
        return null;
      }

      return React.Children.only(this.props.children);
    };

    ThemeProvider.childContextTypes = contextTypes$1;
    ThemeProvider.contextTypes = contextTypes$1;
    return ThemeProvider;
  }(React.Component);

  var withTheme = function withTheme(Component$$1) {
    var componentName = Component$$1.displayName || Component$$1.name || 'Component';

    var WithTheme =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose$2(WithTheme, _React$Component);

      function WithTheme(props) {
        return _React$Component.call(this, props) || this;
      }

      var _proto = WithTheme.prototype;

      _proto.componentWillMount = function componentWillMount() {
        var _this = this;

        var themeContext = this.context[channel$1];

        if (themeContext === undefined) {
          // eslint-disable-next-line no-console
          console.error('[withTheme] Please use ThemeProvider to be able to use withTheme');
          return;
        }

        this.unsubscribeId = themeContext.subscribe(function (theme) {
          _this.setState({
            theme: theme
          });
        });
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        if (this.unsubscribeId !== -1) {
          this.context[channel$1].unsubscribe(this.unsubscribeId);
        }
      };

      _proto.render = function render() {
        return React.createElement(Component$$1, _extends$1({
          theme: this.state.theme
        }, this.props));
      };

      return WithTheme;
    }(React.Component);

    WithTheme.displayName = "WithTheme(" + componentName + ")";
    WithTheme.contextTypes = contextTypes$1;
    return hoistNonReactStatics_cjs(WithTheme, Component$$1);
  };

  var ThemeContext = React.createContext();

  var ThemeProvider$1 = function ThemeProvider$1(_ref) {
    var value = _ref.value,
        children = _ref.children;
    return React.createElement(ThemeProvider, {
      theme: value
    }, React.createElement(ThemeContext.Provider, {
      value: value
    }, children));
  };

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var isComponentKey = function isComponentKey(key) {
    return key.charAt(0) !== key.charAt(0).toLowerCase();
  };

  var _isComponentKey = function _isComponentKey(value, key) {
    return isComponentKey(key);
  };

  var omitComponentKeys = omitByIndexed.bind(null, _isComponentKey);
  var pickComponentKeys = pickByIndexed.bind(null, _isComponentKey);

  var empty = {};

  var unpackRest = function unpackRest(rest) {
    return groupKeys(function (key) {
      if (isComponentKey(key)) {
        return 'components';
      }

      if (isObject(rest[key])) {
        return 'propsDescriptions';
      }

      return 'themeProps';
    }, rest);
  };

  var unpackThemeDescription = (function (themeDescription) {
    if (!themeDescription) {
      return empty;
    }

    var css = themeDescription.css,
        vars = themeDescription.vars,
        rest = _objectWithoutPropertiesLoose(themeDescription, ["css", "vars"]);

    return _extends({
      css: css,
      vars: vars
    }, unpackRest(rest));
  });

  var parsePropsDescriptions = function parsePropsDescriptions(componentName, props, propsDescriptions) {
    if (propsDescriptions === void 0) {
      propsDescriptions = {};
    }

    var activeDescriptions = pickByIndexed(function (value, prop) {
      return props[prop];
    }, propsDescriptions);
    return Object.keys(activeDescriptions).map(function (prop) {
      var _componentDescription;

      var propDescription = activeDescriptions[prop];

      var _unpackThemeDescripti = unpackThemeDescription(propDescription),
          themeProps = _unpackThemeDescripti.themeProps,
          components = _unpackThemeDescripti.components;

      if (!themeProps) {
        return components;
      }

      var componentDescription = (_componentDescription = {}, _componentDescription[componentName] = themeProps, _componentDescription);

      if (!components) {
        return componentDescription;
      }

      return _extends({}, componentDescription, components);
    });
  };

  var mergeInnerTheme = function mergeInnerTheme(componentName) {
    return function (props) {
      return function (theme) {
        var componentDescription = theme[componentName];

        if (!componentDescription) {
          return theme;
        }

        var _unpackThemeDescripti2 = unpackThemeDescription(componentDescription),
            propsDescriptions = _unpackThemeDescripti2.propsDescriptions,
            components = _unpackThemeDescripti2.components;

        if (!propsDescriptions && !components) {
          return theme;
        }

        var activePropsDescriptions = parsePropsDescriptions(componentName, props, propsDescriptions);
        return mergeAll([theme, components].concat(activePropsDescriptions).filter(Boolean));
      };
    };
  };

  var withSubtheme = (function (WrappedComponent) {
    var _class, _temp;

    var wrappedName = WrappedComponent.__ui_kit_name;
    var mergeThemes = mergeInnerTheme(wrappedName);
    return _temp = _class =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose$1(WithSubtheme, _React$Component);

      function WithSubtheme() {
        return _React$Component.apply(this, arguments) || this;
      }

      var _proto = WithSubtheme.prototype;

      _proto.render = function render() {
        var props = this.props;
        return React.createElement(ThemeProvider$1, {
          value: mergeThemes(props)
        }, React.createElement(WrappedComponent, props));
      };

      return WithSubtheme;
    }(React.Component), _class.displayName = "WithSubtheme(" + wrappedName + ")", _temp;
  });

  var styled = createEmotionStyled(emotion, React);
  var registeredComponents = {};

  var unpackCss = function unpackCss(props, css) {
    var basedOnProps = pickBy(isObject, css);

    if (Object.keys(basedOnProps) === 0) {
      return css;
    }

    return compact(mapValuesIndexed(function (value, key) {
      if (!isObject(value)) {
        return value;
      }

      if (key[0] === ':') {
        return unpackCss(props, value);
      }

      var activeProp = find(function (prop) {
        return props[prop];
      }, Object.keys(value)); // if ("development" !== 'production' && !activeProp && !value.default) {
      // 	console.warn(`This css description ("${JSON.stringify(value)}") has no default value.`)
      // }

      return value[activeProp] || value["default"];
    }, css));
  };

  var parseStyles = function parseStyles(props, componentName, mapPropsToStyles) {
    var theme = props.theme,
        style = props.style;

    var _unpackThemeDescripti = unpackThemeDescription(theme[componentName]),
        css = _unpackThemeDescripti.css,
        componentVars = _unpackThemeDescripti.vars,
        themeProps = _unpackThemeDescripti.themeProps;

    var vars = componentVars ? _extends({}, theme.vars, componentVars) : theme.vars; // TODO: should it be possible to specify common props in theme object?

    return [vars, typeof mapPropsToStyles === 'function' && themeProps !== undefined && mapPropsToStyles(themeProps), css && unpackCss(props, css), mapCommonPropsToStyles(props), typeof mapPropsToStyles === 'function' && mapPropsToStyles(props), style];
  };

  var styled$1 = (function (component, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        displayName = _options.displayName,
        displayType = _options.displayType,
        mapPropsToStyles = _options.mapPropsToStyles;

    if (displayName) {
      if (registeredComponents[displayName]) {
        console.warn("\"" + displayName + "\" is already registered. Those names should be unique.");
      }

      registeredComponents[displayName] = true;
    }

    if (!displayName && options.section) {
      console.warn('For `section` components valid `displayName` is required.');
    }

    var factory = styled(component, options);
    return function () {
      var name = displayName || displayType || null;

      for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
        styles[_key] = arguments[_key];
      }

      var styledComponent = factory.apply(void 0, styles.concat([function (props) {
        return parseStyles(props, name, mapPropsToStyles);
      }]));
      styledComponent.__ui_kit_name = name;
      return options.section ? Object.defineProperty(withSubtheme(styledComponent), 'toString', {
        value: styledComponent.toString
      }) : styledComponent;
    };
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
      if (typeof Map !== 'undefined') {
          return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */
      function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
              if (entry[0] === key) {
                  result = index;
                  return true;
              }
              return false;
          });
          return result;
      }
      return /** @class */ (function () {
          function class_1() {
              this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function () {
                  return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */
          class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */
          class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);
              if (~index) {
                  this.__entries__[index][1] = value;
              }
              else {
                  this.__entries__.push([key, value]);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);
              if (~index) {
                  entries.splice(index, 1);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */
          class_1.prototype.clear = function () {
              this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */
          class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) { ctx = null; }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
              }
          };
          return class_1;
      }());
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
          return global;
      }
      if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
      }
      if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
      }
      // eslint-disable-next-line no-new-func
      return Function('return this')();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
      if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
      }
      return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle$1 (callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */
      function resolvePending() {
          if (leadingCall) {
              leadingCall = false;
              callback();
          }
          if (trailingCall) {
              proxy();
          }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */
      function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */
      function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                  return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
          }
          else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
      }
      return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */
          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */
          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */
      ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
          }
          // Add listeners if they haven't been added yet.
          if (!this.connected_) {
              this.connect_();
          }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */
      ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer);
          // Remove observer if it's present in registry.
          if (~index) {
              observers.splice(index, 1);
          }
          // Remove listeners if controller has no connected observers.
          if (!observers.length && this.connected_) {
              this.disconnect_();
          }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */
      ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_();
          // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.
          if (changesDetected) {
              this.refresh();
          }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */
      ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
          });
          // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.
          activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
          return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser$1 || this.connected_) {
              return;
          }
          // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.
          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);
          if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                  attributes: true,
                  childList: true,
                  characterData: true,
                  subtree: true
              });
          }
          else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser$1 || !this.connected_) {
              return;
          }
          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);
          if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */
      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
          // Detect whether transition may affect dimensions of an element.
          var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
              this.refresh();
          }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */
      ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
          }
          return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */
      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
  }());

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = (function (target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
          });
      }
      return target;
  });

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = (function (target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      // Return the local global object if it's not possible extract one from
      // provided element.
      return ownerGlobal || global$1;
  });

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
      return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
      }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
      }
      return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.
      if (!clientWidth && !clientHeight) {
          return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.
      var width = toFloat(styles.width), height = toFloat(styles.height);
      // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).
      if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
      }
      // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.
      if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.
          if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
          }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
      }
      // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens
      return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
          typeof target.getBBox === 'function'); };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
      if (!isBrowser$1) {
          return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      // If DOMRectReadOnly is available use it as a prototype for the rectangle.
      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      // Rectangle's properties are not writable and non-enumerable.
      defineConfigurable(rect, {
          x: x, y: y, width: width, height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
      });
      return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
      return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */
          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */
      ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return (rect.width !== this.broadcastWidth ||
              rect.height !== this.broadcastHeight);
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */
      ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
      };
      return ResizeObservation;
  }());

  var ResizeObserverEntry = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.
          defineConfigurable(this, { target: target, contentRect: contentRect });
      }
      return ResizeObserverEntry;
  }());

  var ResizeObserverSPI = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */
          this.observations_ = new MapShim();
          if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is already being observed.
          if (observations.has(target)) {
              return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          // Force the update of observations.
          this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is not being observed.
          if (!observations.has(target)) {
              return;
          }
          observations.delete(target);
          if (!observations.size) {
              this.controller_.removeObserver(this);
          }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                  _this.activeObservations_.push(observation);
              }
          });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
              return;
          }
          var ctx = this.callbackCtx_;
          // Create ResizeObserverEntry instance for every active observation.
          var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */
      ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI;
  }());

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
          }
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
      }
      return ResizeObserver;
  }());
  // Expose public methods of ResizeObserver.
  [
      'observe',
      'unobserve',
      'disconnect'
  ].forEach(function (method) {
      ResizeObserver.prototype[method] = function () {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
      };
  });

  var index$1 = (function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
      }
      return ResizeObserver;
  })();

  var getBottomFoldPosition = function getBottomFoldPosition(element) {
    return element.scrollTop + element.clientHeight;
  };
  var getOffsetTop = function getOffsetTop(element) {
    return element.getBoundingClientRect().top + window.pageYOffset;
  };

  var isAboveFold = function isAboveFold(container, element) {
    return getOffsetTop(element) - getOffsetTop(container) + element.clientHeight <= container.clientHeight;
  };
  var isScrollOnBottom = function isScrollOnBottom(node, threshold) {
    if (threshold === void 0) {
      threshold = 0;
    }

    return Math.abs(node.scrollTop + node.clientHeight - node.scrollHeight) <= threshold;
  };
  var isScrollOnTop = function isScrollOnTop(node, threshold) {
    if (threshold === void 0) {
      threshold = 0;
    }

    return node.scrollTop <= threshold;
  };
  var isScrolledToRight = function isScrolledToRight(element) {
    return Math.abs(element.scrollLeft + element.clientWidth - element.scrollWidth) <= 1;
  };
  var isScrolledToLeft = function isScrolledToLeft(element) {
    return element.scrollLeft <= 0;
  };
  var scrollToBottom = function scrollToBottom(element) {
    element.scrollTop = element.scrollHeight;
  };
  var scrollToTop = function scrollToTop(element) {
    element.scrollTop = 0;
  };

  var allowScrollEvent = function allowScrollEvent(event) {
    var currentTarget = event.currentTarget,
        deltaY = event.deltaY;
    var scrollTop = currentTarget.scrollTop,
        scrollHeight = currentTarget.scrollHeight;
    var scrollingDown = deltaY > 0;

    if (scrollingDown && deltaY > scrollHeight - getBottomFoldPosition(currentTarget)) {
      currentTarget.scrollTop = scrollHeight;
      return false;
    }

    if (!scrollingDown && -deltaY > scrollTop) {
      currentTarget.scrollTop = 0;
      return false;
    }

    event.stopPropagation();
    return true;
  };
  var containScrollInSubtree = function containScrollInSubtree(event) {
    var allowed = allowScrollEvent(event);

    if (allowed) {
      return;
    }

    event.preventDefault();
  };
  var ENTER_KEYCODE = 13;
  var wasEnterPressed = function wasEnterPressed(event) {
    return event.which === ENTER_KEYCODE;
  };
  var wasNewLineIntended = function wasNewLineIntended(event) {
    return wasEnterPressed(event) && (event.altKey || event.shiftKey);
  };
  var wasOnlyEnterPressed = function wasOnlyEnterPressed(event) {
    return wasEnterPressed(event) && !event.altKey && !event.shiftKey;
  };

  var withPinnedScroll = (function (_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$pinThreshold = _ref.pinThreshold,
        pinThreshold = _ref$pinThreshold === void 0 ? 20 : _ref$pinThreshold,
        _ref$reverse = _ref.reverse,
        reverse = _ref$reverse === void 0 ? false : _ref$reverse;

    return function (WrappedComponent) {
      var _class, _temp2;

      return _temp2 = _class =
      /*#__PURE__*/
      function (_React$Component) {
        _inheritsLoose$1(WithPinnedScroll, _React$Component);

        function WithPinnedScroll() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
          _this._unmounted = false;

          _this._getListRef = function (ref) {
            _this._listRef = ref;

            _this.props.innerRef(ref);
          };

          _this._handleScroll = throttle(200, function (event) {
            if (_this._unmounted) {
              return;
            }

            var _assertThisInitialize = _assertThisInitialized(_this),
                props = _assertThisInitialize.props,
                node = _assertThisInitialize._listRef;

            props.onScroll(event);

            if (isScrollOnBottom(node, pinThreshold)) {
              _this._isAtTheBottom = true;
              props.onScrollBottom(event);
              return;
            }

            _this._isAtTheBottom = false;

            if (isScrollOnTop(node, pinThreshold)) {
              props.onScrollTop(event);
              return;
            }
          });

          _this._handleWheel = function (event) {
            if (_this.props.containScrollInSubtree) {
              containScrollInSubtree(event);
            }

            _this.props.onWheel(event);
          };

          _this.scrollToBottom = function () {
            scrollToBottom(_this._listRef);
            _this._isAtTheBottom = true;
          };

          _this.scrollToTop = function () {
            scrollToTop(_this._listRef);
          };

          _this.scrollProps = {
            isScrollOnBottom: function isScrollOnBottom$1() {
              return isScrollOnBottom(_this._listRef, pinThreshold);
            },
            isScrollOnTop: function isScrollOnTop$1() {
              return isScrollOnTop(_this._listRef, pinThreshold);
            },
            scrollToBottom: _this.scrollToBottom,
            scrollToTop: _this.scrollToTop
          };
          return _this;
        }

        var _proto = WithPinnedScroll.prototype;

        _proto.componentDidMount = function componentDidMount() {
          var _this2 = this;

          if (!this.props.usePinnedScroll) {
            return;
          }

          this._observer = new index$1(function () {
            if (!_this2._isAtTheBottom) {
              return;
            }

            _this2.scrollToBottom();
          });

          this._observer.observe(this._listRef);

          if (reverse) {
            return;
          }

          this.scrollToBottom();
        };

        _proto.componentWillUnmount = function componentWillUnmount() {
          this._unmounted = true;

          if (this._observer) {
            this._observer.disconnect();
          }
        };

        _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
          if (!this.props.usePinnedScroll) {
            return null;
          }

          var node = this._listRef;
          return reverse ? {
            shouldScrollToEdge: isScrollOnTop(node, pinThreshold)
          } : {
            shouldScrollToEdge: isScrollOnBottom(node, pinThreshold),
            prevScrollTop: node.scrollTop,
            scrollTopFromBottomFold: Math.abs(node.scrollTop - node.scrollHeight)
          };
        };

        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {
          if (!this.props.usePinnedScroll) {
            return;
          }

          if (snapshot.shouldScrollToEdge) {
            if (reverse) {
              scrollToTop(this._listRef);
            } else {
              this.scrollToBottom();
            }

            return;
          }

          this._isAtTheBottom = false;

          if (!reverse) {
            this._maybeRestoreScrollPosition(snapshot);
          }
        };

        _proto._maybeRestoreScrollPosition = function _maybeRestoreScrollPosition(_ref2) {
          var prevScrollTop = _ref2.prevScrollTop,
              scrollTopFromBottomFold = _ref2.scrollTopFromBottomFold;
          var node = this._listRef; // if we stay on the top of the list and new items get appended at the top
          // then the scroll position wont change but we have to restore the position nevertheless

          if (node.scrollTop === prevScrollTop && prevScrollTop !== 0) {
            return;
          }

          node.scrollTop = Math.abs(scrollTopFromBottomFold - node.scrollHeight);
        };

        _proto.render = function render() {
          var _this$props = this.props,
              _containScrollInSubtree = _this$props.containScrollInSubtree,
              _onScrollBottom = _this$props.onScrollBottom,
              _onScrollTop = _this$props.onScrollTop,
              _usePinnedScroll = _this$props.usePinnedScroll,
              props = _objectWithoutPropertiesLoose(_this$props, ["containScrollInSubtree", "onScrollBottom", "onScrollTop", "usePinnedScroll"]);

          return React.createElement(WrappedComponent, _extends({}, props, this.scrollProps, {
            innerRef: this._getListRef,
            onScroll: this._handleScroll,
            onWheel: this._handleWheel
          }));
        };

        return WithPinnedScroll;
      }(React.Component), _class.displayName = "WithPinnedScroll(" + getDisplayName(WrappedComponent) + ")", _class.propTypes = {
        containScrollInSubtree: PropTypes.bool,
        innerRef: PropTypes.func,
        onScroll: PropTypes.func,
        onScrollBottom: PropTypes.func,
        onScrollTop: PropTypes.func,
        onWheel: PropTypes.func,
        usePinnedScroll: PropTypes.bool
      }, _class.defaultProps = {
        containScrollInSubtree: false,
        innerRef: noop,
        onScrollBottom: noop,
        onScrollTop: noop,
        onWheel: noop,
        onScroll: noop,
        usePinnedScroll: true
      }, _temp2;
    };
  });

  var StyledList =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'ChatList',
    section: true,
    target: "egyled90"
  })();
  var ChatList = withPinnedScroll({
    reverse: true
  })(StyledList);

  var mapPropsToStyles = function mapPropsToStyles(props) {
    var styles = {};

    if (props.verticalAlign) {
      if (props.verticalAlign === 'top') {
        styles.alignItems = 'flex-start';
      } else if (props.verticalAlign === 'bottom') {
        styles.alignItems = 'flex-end';
      } else {
        styles.alignItems = props.verticalAlign;
      }
    }

    if (props.justify) {
      if (props.justify === true) {
        styles.justifyContent = 'space-between';
      } else if (props.justify === 'left') {
        styles.justifyContent = 'flex-start';
      } else if (props.justify === 'right') {
        styles.justifyContent = 'flex-end';
      } else {
        styles.justifyContent = props.justify;
      }
    }

    if (props.reverse) {
      styles.flexDirection = 'row-reverse';
    }

    return styles;
  };

  var StyledRow =
  /*#__PURE__*/
  styled$1('div', {
    mapPropsToStyles: mapPropsToStyles,
    target: "e108e6fy0"
  })("display:flex;min-width:0;");

  var mapPropsToStyles$1 = function mapPropsToStyles(props) {
    return {
      background: props.active ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0)'
    };
  };

  var StyledItem =
  /*#__PURE__*/
  styled$1(StyledRow, {
    displayName: 'ChatListItem',
    mapPropsToStyles: mapPropsToStyles$1,
    section: true,
    target: "edumshe0"
  })("padding:0.5em;transition:background 0.2s;border-bottom:1px solid rgba(0,0,0,0.1);&:hover{cursor:pointer;}");

  var ChatListItem = function ChatListItem(props) {
    return React.createElement(StyledItem, props);
  };

  ChatListItem.propTypes = {
    active: PropTypes.bool,
    children: PropTypes.node.isRequired
  };

  var StyledBar =
  /*#__PURE__*/
  styled$1(StyledRow, {
    displayName: 'AgentBar',
    section: true,
    target: "e1j58gbc0"
  })("padding:1em;");

  var AgentBar = function AgentBar(props) {
    return React.createElement(StyledBar, _extends({
      verticalAlign: "center"
    }, props));
  };

  AgentBar.propTypes = {
    children: PropTypes.node
  };

  var mapPropsToStyles$2 = function mapPropsToStyles(props) {
    var propsStyle = {};
    var imageStyle = {};
    var size = props.size,
        radius = props.radius,
        fontSize = props.fontSize;

    if (size) {
      propsStyle.width = size;
      propsStyle.height = size;
      propsStyle.lineHeight = size;
    }

    if (radius) {
      propsStyle.borderRadius = radius;
      imageStyle.borderRadius = radius;
    }

    if (fontSize) {
      propsStyle.fontSize = fontSize;
    }

    return _extends({}, propsStyle, {
      '& img': imageStyle
    });
  };

  var StyledAvatar =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'Avatar',
    mapPropsToStyles: mapPropsToStyles$2,
    target: "e11ezd0e0"
  })("border:1px solid #fff;border-radius:50%;text-align:center;background-color:#fff;text-transform:uppercase;img{display:block;border-radius:inherit;width:100%;height:100%;object-fit:cover;}");

  var Avatar = function Avatar(props) {
    var imgUrl = props.imgUrl,
        letter = props.letter;
    var child;

    if (imgUrl) {
      child = React.createElement("img", {
        src: imgUrl
      });
    } else if (letter) {
      child = React.createElement("span", null, letter);
    } else {
      {
        console.warn('Avatar component expects one of imgUrl or letter props.');
      }

      child = null;
    }

    return React.createElement(StyledAvatar, props, child);
  };

  Avatar.propTypes = {
    /** URL of the image */
    imgUrl: PropTypes.string,

    /** Letter to be used instead of the image (when imgUrl is not provided) */
    letter: PropTypes.string,

    /** Avatar size (width and height) */
    size: PropTypes.string,

    /** Override component's styles */
    style: PropTypes.shape()
  };

  var forwardBorderRadiuses =
  /*#__PURE__*/
  css("& >:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit;border-bottom-right-radius:0;border-bottom-left-radius:0;}& >:last-child{border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:inherit;border-bottom-left-radius:inherit;}& >:first-child:last-child{border-top-left-radius:inherit;border-top-right-radius:inherit;border-bottom-right-radius:inherit;border-bottom-left-radius:inherit;}");

  var useTheme = function useTheme() {
    return React.useContext(ThemeContext);
  };

  var useThemeProps = function useThemeProps(displayName) {
    var theme = useTheme();
    var themeProps = React.useMemo(function () {
      return unpackThemeDescription(theme[displayName]).themeProps || {};
    }, [theme]);
    return themeProps;
  };

  var displayName = 'Bubble';

  var flipBorderRadiusesHorizontally = function flipBorderRadiusesHorizontally(_ref) {
    var borderTopLeftRadius = _ref.borderTopLeftRadius,
        borderTopRightRadius = _ref.borderTopRightRadius,
        borderBottomRightRadius = _ref.borderBottomRightRadius,
        borderBottomLeftRadius = _ref.borderBottomLeftRadius;
    return {
      borderTopLeftRadius: borderTopRightRadius,
      borderTopRightRadius: borderTopLeftRadius,
      borderBottomRightRadius: borderBottomLeftRadius,
      borderBottomLeftRadius: borderBottomRightRadius
    };
  };

  var mapPropsToStyles$3 = function mapPropsToStyles(props) {
    var isOwn = props.isOwn,
        ovalBorderRadius = props.ovalBorderRadius,
        sharpBorderRadius = props.sharpBorderRadius,
        radiusType = props.radiusType;
    var borderRadiuses = {
      borderTopLeftRadius: radiusType === 'single' || radiusType === 'first' ? ovalBorderRadius : sharpBorderRadius,
      borderTopRightRadius: ovalBorderRadius,
      borderBottomRightRadius: ovalBorderRadius,
      borderBottomLeftRadius: radiusType === 'single' || radiusType === 'last' ? ovalBorderRadius : sharpBorderRadius // TODO maybe this could be reversed somehow in theme?
      // return isOwn ? flipBorderRadiusesHorizontally(borderRadiuses) : borderRadiuses

    };
    return isOwn ? flipBorderRadiusesHorizontally(borderRadiuses) : borderRadiuses;
  };

  var StyledBubble =
  /*#__PURE__*/
  styled$1(function (props) {
    var themeProps = useThemeProps(displayName);
    return React.createElement("div", _extends({}, themeProps, props));
  }, {
    displayName: displayName,
    shouldForwardProp: index,
    mapPropsToStyles: mapPropsToStyles$3,
    target: "emwkn670"
  })(forwardBorderRadiuses, ";border:1px solid rgba(0,0,0,0.05);display:inline-block;max-width:100%;margin-bottom:0.1em;& img{max-width:100%;display:block;}");
  StyledBubble.propTypes = {
    /** Test of the message */
    children: PropTypes.node,

    /** Message auhor - me (right side) or their (left side) */
    isOwn: PropTypes.bool,

    /** Specifies rendering type, it's used for appropriate corners' rounding */
    radiusType: PropTypes.oneOf(['single', 'first', 'last'])
  };

  var StyledColumn =
  /*#__PURE__*/
  styled$1('div', {
    target: "ek650k30"
  })("display:flex;flex-direction:column;min-width:0;");

  var mapPropsToStyles$4 = function mapPropsToStyles(props) {
    return {
      flexShrink: props.shrink ? 1 : 0
    };
  };

  var StyledFill =
  /*#__PURE__*/
  styled$1('div', {
    mapPropsToStyles: mapPropsToStyles$4,
    target: "e1jdwequ0"
  })();

  var Fill = function Fill(props) {
    return React.createElement(StyledFill, _extends({
      flexFill: true
    }, props));
  };

  Fill.defaultProps = {
    shrink: true
  };
  Fill.propTypes = {
    shrink: PropTypes.bool
  };

  var mapPropsToStyles$5 = function mapPropsToStyles(props) {
    return {
      flexShrink: props.shrink ? 1 : 0
    };
  };

  var StyledFit =
  /*#__PURE__*/
  styled$1('div', {
    mapPropsToStyles: mapPropsToStyles$5,
    target: "e1yi1p4d0"
  })();

  var Fit = function Fit(props) {
    return React.createElement(StyledFit, _extends({
      flexFit: true
    }, props));
  };

  Fit.defaultProps = {
    shrink: true
  };
  Fit.propTypes = {
    shrink: PropTypes.bool
  };

  var StyledButton =
  /*#__PURE__*/
  styled$1('button', {
    displayName: 'IconButton',
    section: true,
    target: "e1m5b1js0"
  })("appearance:none;background:transparent;border:0;display:inline-block;margin:0;padding:0.5em;color:inherit;&:hover{cursor:", function (props) {
    return props.disabled ? 'default' : 'pointer';
  }, ";}&:active,&:focus{outline:none;}");
  StyledButton.propTypes = {
    active: PropTypes.bool,
    disabled: PropTypes.bool,
    children: PropTypes.node.isRequired,
    color: PropTypes.string,
    onClick: PropTypes.func
  };

  var interopRequireDefault = createCommonjsModule(function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
  });

  unwrapExports(interopRequireDefault);

  var hasClass_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = hasClass;

  function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }

  module.exports = exports["default"];
  });

  unwrapExports(hasClass_1);

  var addClass_1 = createCommonjsModule(function (module, exports) {



  exports.__esModule = true;
  exports.default = addClass;

  var _hasClass = interopRequireDefault(hasClass_1);

  function addClass(element, className) {
    if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
  }

  module.exports = exports["default"];
  });

  var addOneClass = unwrapExports(addClass_1);

  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
  }

  var removeClass = function removeClass(element, className) {
    if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  };

  var timeoutsShape = PropTypes__default.oneOfType([PropTypes__default.number, PropTypes__default.shape({
    enter: PropTypes__default.number,
    exit: PropTypes__default.number,
    appear: PropTypes__default.number
  }).isRequired]);
  var classNamesShape = PropTypes__default.oneOfType([PropTypes__default.string, PropTypes__default.shape({
    enter: PropTypes__default.string,
    exit: PropTypes__default.string,
    active: PropTypes__default.string
  }), PropTypes__default.shape({
    enter: PropTypes__default.string,
    enterDone: PropTypes__default.string,
    enterActive: PropTypes__default.string,
    exit: PropTypes__default.string,
    exitDone: PropTypes__default.string,
    exitActive: PropTypes__default.string
  })]);

  var TransitionGroupContext = React__default.createContext(null);

  var UNMOUNTED = 'unmounted';
  var EXITED = 'exited';
  var ENTERING = 'entering';
  var ENTERED = 'entered';
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 1 },
   *   entered:  { opacity: 1 },
   *   exiting:  { opacity: 0 },
   *   exited:  { opacity: 0 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  var Transition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    }; // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }


    var _proto = Transition.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();
        var node = ReactDOM__default.findDOMNode(this);

        if (nextStatus === ENTERING) {
          this.performEnter(node, mounting);
        } else {
          this.performExit(node);
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(node, mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node);
        });
        return;
      }

      this.props.onEnter(node, appearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(node, appearing);

        _this2.onTransitionEnd(node, enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(node, appearing);
          });
        });
      });
    };

    _proto.performExit = function performExit(node) {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

      if (!exit) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
        return;
      }

      this.props.onExit(node);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(node);

        _this3.onTransitionEnd(node, timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(node);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
      this.setNextCallback(handler);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }

      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children,
          childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


      delete childProps.in;
      delete childProps.mountOnEnter;
      delete childProps.unmountOnExit;
      delete childProps.appear;
      delete childProps.enter;
      delete childProps.exit;
      delete childProps.timeout;
      delete childProps.addEndListener;
      delete childProps.onEnter;
      delete childProps.onEntering;
      delete childProps.onEntered;
      delete childProps.onExit;
      delete childProps.onExiting;
      delete childProps.onExited;

      if (typeof children === 'function') {
        // allows for nested Transitions
        return React__default.createElement(TransitionGroupContext.Provider, {
          value: null
        }, children(status, childProps));
      }

      var child = React__default.Children.only(children);
      return (// allows for nested Transitions
        React__default.createElement(TransitionGroupContext.Provider, {
          value: null
        }, React__default.cloneElement(child, childProps))
      );
    };

    return Transition;
  }(React__default.Component);

  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`, `'unmounted'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

    /**
     * Show the component; triggers the enter or exit states
     */
    in: PropTypes.bool,

    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: PropTypes.bool,

    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: PropTypes.bool,

    /**
     * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.
     * If you want to transition on the first mount set `appear` to `true`, and the
     * component will transition in as soon as the `<Transition>` mounts.
     *
     * > Note: there are no specific "appear" states. `appear` only adds an additional `enter` transition.
     */
    appear: PropTypes.bool,

    /**
     * Enable or disable enter transitions.
     */
    enter: PropTypes.bool,

    /**
     * Enable or disable exit transitions.
     */
    exit: PropTypes.bool,

    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener) pt = pt.isRequired;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return pt.apply(void 0, [props].concat(args));
    },

    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. **Note:** Timeouts are still used as a fallback if provided.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: PropTypes.func,

    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: PropTypes.func,

    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,

    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: PropTypes.func,

    /**
     * Callback fired before the "exiting" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: PropTypes.func,

    /**
     * Callback fired after the "exiting" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: PropTypes.func,

    /**
     * Callback fired after the "exited" status is applied.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: PropTypes.func // Name the function so it is clearer in the documentation

  };

  function noop$1() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$1,
    onEntering: noop$1,
    onEntered: noop$1,
    onExit: noop$1,
    onExiting: noop$1,
    onExited: noop$1
  };
  Transition.UNMOUNTED = 0;
  Transition.EXITED = 1;
  Transition.ENTERING = 2;
  Transition.ENTERED = 3;
  Transition.EXITING = 4;

  var _addClass = function addClass(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return addOneClass(node, c);
    });
  };

  var removeClass$1 = function removeClass$1(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return removeClass(node, c);
    });
  };
  /**
   * A transition component inspired by the excellent
   * [ng-animate](http://www.nganimate.org/) library, you should use it if you're
   * using CSS transitions or animations. It's built upon the
   * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
   * component, so it inherits all of its props.
   *
   * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
   * and `exit` states of the transition. The first class is applied and then a
   * second `*-active` class in order to activate the CSSS transition. After the
   * transition, matching `*-done` class names are applied to persist the
   * transition state.
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
   *         <div>
   *           {"I'll receive my-node-* classes"}
   *         </div>
   *       </CSSTransition>
   *       <button type="button" onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the `in` prop is set to `true`, the child component will first receive
   * the class `example-enter`, then the `example-enter-active` will be added in
   * the next tick. `CSSTransition` [forces a
   * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
   * between before adding the `example-enter-active`. This is an important trick
   * because it allows us to transition between `example-enter` and
   * `example-enter-active` even though they were added immediately one after
   * another. Most notably, this is what makes it possible for us to animate
   * _appearance_.
   *
   * ```css
   * .my-node-enter {
   *   opacity: 0;
   * }
   * .my-node-enter-active {
   *   opacity: 1;
   *   transition: opacity 200ms;
   * }
   * .my-node-exit {
   *   opacity: 1;
   * }
   * .my-node-exit-active {
   *   opacity: 0;
   *   transition: opacity 200ms;
   * }
   * ```
   *
   * `*-active` classes represent which styles you want to animate **to**.
   */


  var CSSTransition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(CSSTransition, _React$Component);

    function CSSTransition() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };

      _this.onEnter = function (node, appearing) {
        _this.removeClasses(node, 'exit');

        _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

        if (_this.props.onEnter) {
          _this.props.onEnter(node, appearing);
        }
      };

      _this.onEntering = function (node, appearing) {
        var type = appearing ? 'appear' : 'enter';

        _this.addClass(node, type, 'active');

        if (_this.props.onEntering) {
          _this.props.onEntering(node, appearing);
        }
      };

      _this.onEntered = function (node, appearing) {
        var type = appearing ? 'appear' : 'enter';

        _this.removeClasses(node, type);

        _this.addClass(node, type, 'done');

        if (_this.props.onEntered) {
          _this.props.onEntered(node, appearing);
        }
      };

      _this.onExit = function (node) {
        _this.removeClasses(node, 'appear');

        _this.removeClasses(node, 'enter');

        _this.addClass(node, 'exit', 'base');

        if (_this.props.onExit) {
          _this.props.onExit(node);
        }
      };

      _this.onExiting = function (node) {
        _this.addClass(node, 'exit', 'active');

        if (_this.props.onExiting) {
          _this.props.onExiting(node);
        }
      };

      _this.onExited = function (node) {
        _this.removeClasses(node, 'exit');

        _this.addClass(node, 'exit', 'done');

        if (_this.props.onExited) {
          _this.props.onExited(node);
        }
      };

      _this.getClassNames = function (type) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === 'string';
        var prefix = isStringClassNames && classNames ? classNames + "-" : '';
        var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
        return {
          baseClassName: baseClassName,
          activeClassName: activeClassName,
          doneClassName: doneClassName
        };
      };

      return _this;
    }

    var _proto = CSSTransition.prototype;

    _proto.addClass = function addClass(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];

      if (type === 'appear' && phase === 'done') {
        className += " " + this.getClassNames('enter').doneClassName;
      } // This is for to force a repaint,
      // which is necessary in order to transition styles when adding a class name.


      if (phase === 'active') {
        /* eslint-disable no-unused-expressions */
        node && node.scrollTop;
      }

      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    };

    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type],
          baseClassName = _this$appliedClasses$.base,
          activeClassName = _this$appliedClasses$.active,
          doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};

      if (baseClassName) {
        removeClass$1(node, baseClassName);
      }

      if (activeClassName) {
        removeClass$1(node, activeClassName);
      }

      if (doneClassName) {
        removeClass$1(node, doneClassName);
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          _ = _this$props.classNames,
          props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

      return React__default.createElement(Transition, _extends({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };

    return CSSTransition;
  }(React__default.Component);

  CSSTransition.defaultProps = {
    classNames: ''
  };
  CSSTransition.propTypes = _extends({}, Transition.propTypes, {
    /**
     * The animation classNames applied to the component as it enters, exits or
     * has finished the transition. A single name can be provided and it will be
     * suffixed for each stage: e.g.
     *
     * `classNames="fade"` applies `fade-enter`, `fade-enter-active`,
     * `fade-enter-done`, `fade-exit`, `fade-exit-active`, `fade-exit-done`,
     * `fade-appear`, `fade-appear-active`, and `fade-appear-done`.
     *
     * **Note**: `fade-appear-done` and `fade-enter-done` will _both_ be applied.
     * This allows you to define different behavior for when appearing is done and
     * when regular entering is done, using selectors like
     * `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply an
     * epic entrance animation when element first appears in the DOM using
     * [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
     * simply use `fade-enter-done` for defining both cases.
     *
     * Each individual classNames can also be specified independently like:
     *
     * ```js
     * classNames={{
     *  appear: 'my-appear',
     *  appearActive: 'my-active-appear',
     *  appearDone: 'my-done-appear',
     *  enter: 'my-enter',
     *  enterActive: 'my-active-enter',
     *  enterDone: 'my-done-enter',
     *  exit: 'my-exit',
     *  exitActive: 'my-active-exit',
     *  exitDone: 'my-done-exit',
     * }}
     * ```
     *
     * If you want to set these classes using CSS Modules:
     *
     * ```js
     * import styles from './styles.css';
     * ```
     *
     * you might want to use camelCase in your CSS file, that way could simply
     * spread them instead of listing them one by one:
     *
     * ```js
     * classNames={{ ...styles }}
     * ```
     *
     * @type {string | {
     *  appear?: string,
     *  appearActive?: string,
     *  appearDone?: string,
     *  enter?: string,
     *  enterActive?: string,
     *  enterDone?: string,
     *  exit?: string,
     *  exitActive?: string,
     *  exitDone?: string,
     * }}
     */
    classNames: classNamesShape,

    /**
     * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
     * applied.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEnter: PropTypes.func,

    /**
     * A `<Transition>` callback fired immediately after the 'enter-active' or
     * 'appear-active' class is applied.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,

    /**
     * A `<Transition>` callback fired immediately after the 'enter' or
     * 'appear' classes are **removed** and the `done` class is added to the DOM node.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntered: PropTypes.func,

    /**
     * A `<Transition>` callback fired immediately after the 'exit' class is
     * applied.
     *
     * @type Function(node: HtmlElement)
     */
    onExit: PropTypes.func,

    /**
     * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
     *
     * @type Function(node: HtmlElement)
     */
    onExiting: PropTypes.func,

    /**
     * A `<Transition>` callback fired immediately after the 'exit' classes
     * are **removed** and the `exit-done` class is added to the DOM node.
     *
     * @type Function(node: HtmlElement)
     */
    onExited: PropTypes.func
  });

  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */

  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && React.isValidElement(child) ? mapFn(child) : child;
    };

    var result = Object.create(null);
    if (children) React.Children.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */

  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list


    var nextKeysPending = Object.create(null);
    var pendingKeys = [];

    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};

    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }

      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`


    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }

  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }

  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return React.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (!React.isValidElement(child)) return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = React.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = React.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && React.isValidElement(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }

  var values$1 = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };

  var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
    /**
     * The `<TransitionGroup>` component manages a set of transition components
     * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
     * components, `<TransitionGroup>` is a state machine for managing the mounting
     * and unmounting of components over time.
     *
     * Consider the example below. As items are removed or added to the TodoList the
     * `in` prop is toggled automatically by the `<TransitionGroup>`.
     *
     * Note that `<TransitionGroup>`  does not define any animation behavior!
     * Exactly _how_ a list item animates is up to the individual transition
     * component. This means you can mix and match animations across different list
     * items.
     */

  };

  var TransitionGroup =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(TransitionGroup, _React$Component);

    function TransitionGroup(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;

      var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }

    var _proto = TransitionGroup.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };

    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;

      if (child.props.onExited) {
        child.props.onExited(node);
      }

      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends({}, state.children);

          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

      var contextValue = this.state.contextValue;
      var children = values$1(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;

      if (Component === null) {
        return React__default.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }

      return React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, React__default.createElement(Component, props, children));
    };

    return TransitionGroup;
  }(React__default.Component);

  TransitionGroup.propTypes = {
    /**
     * `<TransitionGroup>` renders a `<div>` by default. You can change this
     * behavior by providing a `component` prop.
     * If you use React v16+ and would like to avoid a wrapping `<div>` element
     * you can pass in `component={null}`. This is useful if the wrapping div
     * borks your css styles.
     */
    component: PropTypes__default.any,

    /**
     * A set of `<Transition>` components, that are toggled `in` and out as they
     * leave. the `<TransitionGroup>` will inject specific transition props, so
     * remember to spread them through if you are wrapping the `<Transition>` as
     * with our `<Fade>` example.
     *
     * While this component is meant for multiple `Transition` or `CSSTransition`
     * children, sometimes you may want to have a single transition child with
     * content that you want to be transitioned out and in when you change it
     * (e.g. routes, images etc.) In that case you can change the `key` prop of
     * the transition child as you change its content, this will cause
     * `TransitionGroup` to transition the child out and back in.
     */
    children: PropTypes__default.node,

    /**
     * A convenience prop that enables or disables appear animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    appear: PropTypes__default.bool,

    /**
     * A convenience prop that enables or disables enter animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    enter: PropTypes__default.bool,

    /**
     * A convenience prop that enables or disables exit animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    exit: PropTypes__default.bool,

    /**
     * You may need to apply reactive updates to a child as it is exiting.
     * This is generally done by using `cloneElement` however in the case of an exiting
     * child the element has already been removed and not accessible to the consumer.
     *
     * If you do need to update a child as it leaves you can provide a `childFactory`
     * to wrap every child, even the ones that are leaving.
     *
     * @type Function(child: ReactElement) -> ReactElement
     */
    childFactory: PropTypes__default.func
  };
  TransitionGroup.defaultProps = defaultProps;

  var classCallCheck$1 = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits$1 = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn$1 = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var callAll = function () {
    for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return fns.forEach(function (fn) {
        return fn && fn.apply(undefined, args);
      });
    };
  };
  var noop$2 = function () {};

  var Toggle = function (_Component) {
    inherits$1(Toggle, _Component);

    function Toggle() {
      var _temp, _this, _ret;

      classCallCheck$1(this, Toggle);

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn$1(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
        on: _this.getOn({ on: _this.props.defaultOn })
      }, _this.getTogglerProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return _extends$2({
          'aria-expanded': Boolean(_this.getOn()),
          tabIndex: 0
        }, props, {
          onClick: callAll(props.onClick, _this.toggle)
        });
      }, _this.toggleKeys = ['Enter', ' '], _this.getInputTogglerProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return _this.getTogglerProps(_extends$2({}, props, {
          onKeyUp: callAll(props.onKeyUp, function (event) {
            if (event.key === 'Enter') {
              // <input> already respond to Enter
              _this.toggle();
            }
          })
        }));
      }, _this.getElementTogglerProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return _this.getTogglerProps(_extends$2({}, props, {
          onKeyUp: callAll(props.onKeyUp, function (event) {
            if (_this.toggleKeys.indexOf(event.key) > -1) {
              _this.toggle();
            }
          })
        }));
      }, _this.setOnState = function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !_this.getOn();

        var cb = _this.getOn() === state ? noop$2 : function () {
          _this.props.onToggle(state, _this.getTogglerStateAndHelpers());
        };
        _this.setState({ on: state }, cb);
      }, _this.setOn = _this.setOnState.bind(_this, true), _this.setOff = _this.setOnState.bind(_this, false), _this.toggle = _this.setOnState.bind(_this, undefined), _temp), possibleConstructorReturn$1(_this, _ret);
    }

    Toggle.prototype.getOn = function getOn() {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;

      return this.isOnControlled() ? props.on : state.on;
    };

    Toggle.prototype.isOnControlled = function isOnControlled() {
      return this.props.on !== undefined;
    }; // This matches <button> behavior

    Toggle.prototype.getTogglerStateAndHelpers = function getTogglerStateAndHelpers() {
      return {
        on: this.getOn(),
        getTogglerProps: this.getTogglerProps,
        getInputTogglerProps: this.getInputTogglerProps,
        getElementTogglerProps: this.getElementTogglerProps,
        setOn: this.setOn,
        setOff: this.setOff,
        toggle: this.toggle
      };
    };

    Toggle.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref) {
      var on = _ref.on;

      if (on !== this.props.on && on !== this.state.on) {
        this.setOnState(on);
      }
    };

    Toggle.prototype.render = function render() {
      var renderProp = unwrapArray(this.props.children);
      return renderProp(this.getTogglerStateAndHelpers());
    };

    return Toggle;
  }(React.Component);

  /**
   * Takes an argument and if it's an array, returns the first item in the array
   * otherwise returns the argument
   * @param {*} arg the maybe-array
   * @return {*} the arg or it's first item
   */


  Toggle.defaultProps = {
    defaultOn: false,
    onToggle: noop$2
  };
  Toggle.propTypes = {
    defaultOn: PropTypes__default.bool,
    on: PropTypes__default.bool,
    onToggle: PropTypes__default.func,
    children: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.array]).isRequired
  };
  function unwrapArray(arg) {
    return Array.isArray(arg) ? arg[0] : arg;
  }

  var _React$createContext = React.createContext({
    isScrollOnBottom: noop,
    isScrollOnTop: noop,
    registerUnseenListItem: noop,
    scrollToBottom: noop,
    scrollToTop: noop
  }),
      MessageListProvider = _React$createContext.Provider,
      MessageListSpy = _React$createContext.Consumer;

  var autoInc = function autoInc(start) {
    if (start === void 0) {
      start = 0;
    }

    var counter = start;
    return function () {
      return counter++;
    };
  };

  var nextId = autoInc();
  var StyledList$1 =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageList',
    target: "e1i3n9g60"
  })("padding:0.5em;overflow-y:auto;height:100%;");

  var MessageList =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(MessageList, _React$Component);

    function MessageList() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this._listItems = [];

      _this._registerUnseenListItem = function (listItemDescription) {
        var id = nextId();

        _this._listItems.push(_extends({}, listItemDescription, {
          id: id
        }));

        return _this._unregisterUnseenListItem.bind(_assertThisInitialized(_this), id);
      };

      _this._unregisterUnseenListItem = function (id) {
        var index = findIndex(function (_ref) {
          var itemId = _ref.id;
          return itemId === id;
        }, _this._listItems);

        if (index === -1) {
          return;
        }

        _this._listItems.splice(index, 1);
      };

      _this._getListRef = function (ref) {
        _this.listRef = ref;

        _this.props.innerRef(ref);
      };

      _this._handleScroll = throttle(300, function (event) {
        if (_this.props.active) {
          _this.callSeenCallbacks();
        }

        _this.props.onScroll(event);
      });
      _this._context = {
        isScrollOnBottom: _this.props.isScrollOnBottom,
        isScrollOnTop: _this.props.isScrollOnTop,
        registerUnseenListItem: _this._registerUnseenListItem,
        scrollToBottom: _this.props.scrollToBottom,
        scrollToTop: _this.props.scrollToTop
      };
      return _this;
    }

    var _proto = MessageList.prototype;

    _proto.componentDidMount = function componentDidMount() {
      if (this.props.active === true) {
        this.callSeenCallbacks();
      }
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (prevProps.active === false && this.props.active === true) {
        this.callSeenCallbacks();
      }
    };

    _proto.callSeenCallbacks = function callSeenCallbacks() {
      var _this2 = this;

      this._listItems.forEach(function (listItem) {
        if (!isAboveFold(_this2.listRef, listItem.ref)) {
          return;
        }

        listItem.onSeen();
      });
    };

    _proto.render = function render() {
      return React.createElement(MessageListProvider, {
        value: this._context
      }, React.createElement(StyledList$1, _extends({}, this.props, {
        innerRef: this._getListRef,
        onScroll: this._handleScroll
      })));
    };

    return MessageList;
  }(React.Component);

  MessageList.propTypes = {
    /** This prop tell us if we should call onSeen callbacks from contained MessageListItems when scrolling */
    active: PropTypes.bool,

    /** Children of the list */
    children: PropTypes.node.isRequired,

    /** Prop used as function ref to the underlaying DOM element */
    innerRef: PropTypes.func,

    /** Callback hooked into list's scroll event */
    onScroll: PropTypes.func
  };
  MessageList.defaultProps = {
    active: true,
    innerRef: noop,
    onScroll: noop
  };
  var MessageList$1 = withPinnedScroll()(MessageList);

  var MessageListItem =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(MessageListItem, _React$Component);

    function MessageListItem() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this._unregisterFromMessageList = noop;
      _this._registerInMessageList = memoizeOne(function (register) {
        return function (ref) {
          // this only handles null ref (when it stops to listen to onSeen - when this.props.seen transition from true to false)
          _this._unregisterFromMessageList();

          if (!ref) {
            return;
          }

          _this._unregisterFromMessageList = register({
            ref: ref,
            onSeen: _this.props.onSeen
          });
        };
      });
      return _this;
    }

    var _proto = MessageListItem.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._unregisterFromMessageList();
    };

    _proto.render = function render() {
      var _this2 = this;

      return React.createElement(MessageListSpy, null, function (_ref) {
        var registerUnseenListItem = _ref.registerUnseenListItem;
        return React.createElement("div", {
          ref: _this2.props.seen ? null : _this2._registerInMessageList(registerUnseenListItem)
        }, React.Children.only(_this2.props.children));
      });
    };

    return MessageListItem;
  }(React.Component);

  MessageListItem.propTypes = {
    children: PropTypes.node.isRequired,
    onSeen: PropTypes.func
  };
  MessageListItem.defaultProps = {
    onSeen: noop
  };

  var fade =
  /*#__PURE__*/
  css("&-enter{opacity:0;height:0;}&-enter&-enter-active{opacity:1;height:1.2em;transition:height 200ms ease-in-out,opacity 100ms ease-in-out 100ms;}&-exit{opacity:1;height:1.2em;}&-exit&-exit-active{opacity:0;height:0;transition:height 100ms ease-in-out 100ms,opacity 200ms ease-in-out;}");

  var Fade = function Fade(_ref) {
    var children = _ref.children,
        props = _objectWithoutPropertiesLoose(_ref, ["children"]);

    return React.createElement(CSSTransition, _extends({}, props, {
      classNames: fade,
      timeout: 200
    }), children);
  };

  Fade.propTypes = {
    children: PropTypes.node
  };

  var mapPropsToStyles$6 = function mapPropsToStyles(_ref) {
    var horizontalAlign = _ref.horizontalAlign;

    if (!horizontalAlign) {
      return null;
    }

    return {
      flexDirection: horizontalAlign === 'left' ? 'row' : 'row-reverse'
    };
  }; // TODO: check out if this element should be flex, seems it might be some leftover, need to check all browsers


  var StyledMessage =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'Message',
    mapPropsToStyles: mapPropsToStyles$6,
    section: true,
    target: "e10ccb470"
  })("display:flex;align-items:flex-start;font-size:0.9em;margin:0.3em;max-width:100%;");
  var AuthorName =
  /*#__PURE__*/
  styled$1('span', {
    displayName: 'AuthorName',
    target: "e10ccb471"
  })("font-size:0.8em;");
  var MessageMeta =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageMeta',
    target: "e10ccb472"
  })("text-align:left;");
  var Content =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'Content',
    target: "e10ccb473"
  })("display:flex;flex-direction:column;overflow:hidden;align-items:flex-start;");
  var Time =
  /*#__PURE__*/
  styled$1('span', {
    displayName: 'Time',
    target: "e10ccb474"
  })("font-size:0.8em;");
  var Status =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'Status',
    target: "e10ccb475"
  })("text-align:right;font-size:0.8em;");

  var Message =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(Message, _React$Component);

    function Message() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Message.prototype;

    _proto.render = function render() {
      var _this$props = this.props,
          children = _this$props.children,
          authorName = _this$props.authorName,
          deliveryStatus = _this$props.deliveryStatus,
          isOwn = _this$props.isOwn,
          date = _this$props.date,
          showMetaOnClick = _this$props.showMetaOnClick,
          onSeen = _this$props.onSeen,
          radiusType = _this$props.radiusType,
          seen = _this$props.seen,
          props = _objectWithoutPropertiesLoose(_this$props, ["children", "authorName", "deliveryStatus", "isOwn", "date", "showMetaOnClick", "onSeen", "radiusType", "seen"]);

      var message = React.createElement(Toggle, null, function (_ref2) {
        var authorOpened = _ref2.on,
            getElementTogglerProps = _ref2.getElementTogglerProps;
        return React.createElement(StyledMessage, _extends({}, getElementTogglerProps(props), {
          own: isOwn,
          tabIndex: null
        }), React.createElement(Content, null, React.createElement(TransitionGroup, null, (!showMetaOnClick || authorOpened) && React.createElement(Fade, null, React.createElement(MessageMeta, null, authorName && React.createElement(AuthorName, null, authorName, " "), date && React.createElement(Time, null, date)))), children, deliveryStatus && React.createElement(Status, null, deliveryStatus)));
      });
      return React.createElement(MessageListItem, {
        onSeen: onSeen,
        seen: seen
      }, message);
    };

    return Message;
  }(React.Component);

  Message.propTypes = {
    /** Message author's name */
    authorName: PropTypes.string,
    authorOpened: PropTypes.bool,

    /** Message children components */
    children: PropTypes.node,

    /** Message date */
    date: PropTypes.string,
    deliveryStatus: PropTypes.string,

    /** Message author - agent (left side) or visitor (right side) */
    isOwn: PropTypes.bool,
    onClick: PropTypes.func,

    /** Callback called when the user scrolls the list to the message. Message must be wrapped by MessageList component. */
    onSeen: PropTypes.func,
    showMetaOnClick: PropTypes.bool,

    /** Override component's styles */
    style: PropTypes.shape(),
    toggleAuthor: PropTypes.func,

    /** Specifies rendering type, it's used for appropriate corners' rounding */
    radiusType: PropTypes.oneOf(['single', 'first', 'last']),
    seen: PropTypes.bool
  };
  Message.defaultProps = {
    onClick: function onClick() {},
    seen: false
  };

  var SubTitle =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'SubTitle',
    target: "e1fut3qs0"
  })("font-weight:300;opacity:0.7;");
  SubTitle.defaultProps = {
    textWrap: true
  };

  var Title =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'Title',
    target: "e9xf8br0"
  })("font-weight:500;");
  Title.defaultProps = {
    textWrap: true
  };

  var warnOnce = once(console.warn.bind(console));
  var StyledTitle =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageTitle',
    target: "e1ykjxgu0"
  })("font-weight:600;padding:1em;");
  var marginBottomClass =
  /*#__PURE__*/
  css("margin-bottom:4px;");

  var MessageTitle = function MessageTitle(_ref) {
    var children = _ref.children,
        title = _ref.title,
        subtitle = _ref.subtitle,
        props = _objectWithoutPropertiesLoose(_ref, ["children", "title", "subtitle"]);

    if (children && (title || subtitle)) {
      // eslint-disable-next-line no-console
      warnOnce(['You should not use title nor subtitle & children props together.', 'They cannot be rendered at once - children prop has higher rendering priority.'].join('\n'));
    }

    var childs = children ? children : [title && React.createElement(Title, {
      key: "title",
      className: marginBottomClass
    }, title), subtitle && React.createElement(SubTitle, {
      key: "subtitle",
      preserveLines: true
    }, subtitle)];
    return React.createElement(StyledTitle, props, childs);
  };

  MessageTitle.propTypes = {
    children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
    subtitle: PropTypes.string,
    title: PropTypes.string
  };

  var StyledText =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageText',
    target: "eovu8nx0"
  })("white-space:pre-line;word-wrap:break-word;overflow-wrap:break-word;max-width:100%;padding:1em;");

  var mapPropsToStyles$7 = function mapPropsToStyles(props) {
    var _ref = props.style || {},
        borderTopLeftRadius = _ref.borderTopLeftRadius,
        borderTopRightRadius = _ref.borderTopRightRadius,
        borderBottomRightRadius = _ref.borderBottomRightRadius,
        borderBottomLeftRadius = _ref.borderBottomLeftRadius;

    return {
      img: {
        borderTopLeftRadius: borderTopLeftRadius,
        borderTopRightRadius: borderTopRightRadius,
        borderBottomRightRadius: borderBottomRightRadius,
        borderBottomLeftRadius: borderBottomLeftRadius
      }
    };
  };

  var StyledMedia =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageMedia',
    mapPropsToStyles: mapPropsToStyles$7,
    target: "evmhqt80"
  })("overflow:hidden;");

  var borderColor = 'rgba(0, 0, 0, 0.1)';
  var border = "1px solid " + borderColor;
  var StyledButtons =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageButtons',
    target: "edowbh60"
  })(forwardBorderRadiuses, ";& >:first-child{border-top:", border, ";}&:first-child >:first-child{border-top:0;}& >:last-child{border-bottom:", border, ";}&:last-child >:last-child{border-bottom:0;}> *{border-color:", borderColor, " !important;}");

  //      

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };



















  var _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _opinionatedRules;
  var _abbrTitle;
  var _unopinionatedRules;

  //      
  var opinionatedRules = (_opinionatedRules = {
    html: {
      fontFamily: 'sans-serif'
    },

    body: {
      margin: '0'
    }

  }, _opinionatedRules['a:active,\n  a:hover'] = {
    outlineWidth: '0'
  }, _opinionatedRules['button,\n  input,\n  optgroup,\n  select,\n  textarea'] = {
    fontFamily: 'sans-serif',
    fontSize: '100%',
    lineHeight: '1.15'
  }, _opinionatedRules);

  var unopinionatedRules = (_unopinionatedRules = {
    html: {
      lineHeight: '1.15',
      textSizeAdjust: '100%'
    }

  }, _unopinionatedRules['article,\n  aside,\n  footer,\n  header,\n  nav,\n  section'] = {
    display: 'block'
  }, _unopinionatedRules.h1 = {
    fontSize: '2em',
    margin: '0.67em 0'
  }, _unopinionatedRules['figcaption,\n  figure,\n  main'] = {
    display: 'block'
  }, _unopinionatedRules.figure = {
    margin: '1em 40px'
  }, _unopinionatedRules.hr = {
    boxSizing: 'content-box',
    height: '0',
    overflow: 'visible'
  }, _unopinionatedRules.pre = {
    fontFamily: 'monospace, monospace',
    fontSize: '1em'
  }, _unopinionatedRules.a = {
    'background-color': 'transparent',
    '-webkit-text-decoration-skip': 'objects'
  }, _unopinionatedRules['abbr[title]'] = (_abbrTitle = {
    borderBottom: 'none',
    textDecoration: 'underline'
  }, _abbrTitle['textDecoration'] = 'underline dotted', _abbrTitle), _unopinionatedRules['b,\n  strong'] = {
    fontWeight: 'inherit'
  }, _unopinionatedRules['code,\n  kbd,\n  samp'] = {
    fontFamily: 'monospace, monospace',
    fontSize: '1em'
  }, _unopinionatedRules.dfn = {
    fontStyle: 'italic'
  }, _unopinionatedRules.mark = {
    backgroundColor: '#ff0',
    color: '#000'
  }, _unopinionatedRules.small = {
    fontSize: '80%'
  }, _unopinionatedRules['sub,\n  sup'] = {
    fontSize: '75%',
    lineHeight: '0',
    position: 'relative',
    verticalAlign: 'baseline'
  }, _unopinionatedRules.sub = {
    bottom: '-0.25em'
  }, _unopinionatedRules.sup = {
    top: '-0.5em'
  }, _unopinionatedRules['audio,\n  video'] = {
    display: 'inline-block'
  }, _unopinionatedRules['audio:not([controls])'] = {
    display: 'none',
    height: '0'
  }, _unopinionatedRules.img = {
    borderStyle: 'none'
  }, _unopinionatedRules['svg:not(:root)'] = {
    overflow: 'hidden'
  }, _unopinionatedRules['button,\n  input,\n  optgroup,\n  select,\n  textarea'] = {
    margin: '0'
  }, _unopinionatedRules['button,\n  input'] = {
    overflow: 'visible'
  }, _unopinionatedRules['button,\n  select'] = {
    textTransform: 'none'
  }, _unopinionatedRules['button,\n  html [type="button"],\n  [type="reset"],\n  [type="submit"]'] = {
    '-webkit-appearance': 'button'
  }, _unopinionatedRules['button::-moz-focus-inner,\n  [type="button"]::-moz-focus-inner,\n  [type="reset"]::-moz-focus-inner,\n  [type="submit"]::-moz-focus-inner'] = {
    borderStyle: 'none',
    padding: '0'
  }, _unopinionatedRules['button:-moz-focusring,\n  [type="button"]:-moz-focusring,\n  [type="reset"]:-moz-focusring,\n  [type="submit"]:-moz-focusring'] = {
    outline: '1px dotted ButtonText'
  }, _unopinionatedRules.fieldset = {
    border: '1px solid #c0c0c0',
    margin: '0 2px',
    padding: '0.35em 0.625em 0.75em'
  }, _unopinionatedRules.legend = {
    boxSizing: 'border-box',
    color: 'inherit',
    display: 'table',
    maxWidth: '100%',
    padding: '0',
    whiteSpace: 'normal'
  }, _unopinionatedRules.progress = {
    display: 'inline-block',
    verticalAlign: 'baseline'
  }, _unopinionatedRules.textarea = {
    overflow: 'auto'
  }, _unopinionatedRules['[type="checkbox"],\n  [type="radio"]'] = {
    boxSizing: 'border-box',
    padding: '0'
  }, _unopinionatedRules['[type="number"]::-webkit-inner-spin-button,\n  [type="number"]::-webkit-outer-spin-button'] = {
    height: 'auto'
  }, _unopinionatedRules['[type="search"]'] = {
    '-webkit-appearance': 'textfield',
    outlineOffset: '-2px'
  }, _unopinionatedRules['[type="search"]::-webkit-search-cancel-button,\n  [type="search"]::-webkit-search-decoration'] = {
    '-webkit-appearance': 'none'
  }, _unopinionatedRules['::-webkit-file-upload-button'] = {
    '-webkit-appearance': 'button',
    font: 'inherit'
  }, _unopinionatedRules['details,\n  menu'] = {
    display: 'block'
  }, _unopinionatedRules.summary = {
    display: 'list-item'
  }, _unopinionatedRules.canvas = {
    display: 'inline-block'
  }, _unopinionatedRules.template = {
    display: 'none'
  }, _unopinionatedRules['[hidden]'] = {
    display: 'none'
  }, _unopinionatedRules);

  //      


  function colorToInt(color) {
    return Math.round(color * 255);
  }

  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }

  function hslToRgb(hue, saturation, lightness) {
    var convert = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : convertToInt;

    if (saturation === 0) {
      // achromatic
      return convert(lightness, lightness, lightness);
    }

    // formular from https://en.wikipedia.org/wiki/HSL_and_HSV
    var huePrime = hue % 360 / 60;
    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));

    var red = 0;
    var green = 0;
    var blue = 0;

    if (huePrime >= 0 && huePrime < 1) {
      red = chroma;
      green = secondComponent;
    } else if (huePrime >= 1 && huePrime < 2) {
      red = secondComponent;
      green = chroma;
    } else if (huePrime >= 2 && huePrime < 3) {
      green = chroma;
      blue = secondComponent;
    } else if (huePrime >= 3 && huePrime < 4) {
      green = secondComponent;
      blue = chroma;
    } else if (huePrime >= 4 && huePrime < 5) {
      red = secondComponent;
      blue = chroma;
    } else if (huePrime >= 5 && huePrime < 6) {
      red = chroma;
      blue = secondComponent;
    }

    var lightnessModification = lightness - chroma / 2;
    var finalRed = red + lightnessModification;
    var finalGreen = green + lightnessModification;
    var finalBlue = blue + lightnessModification;
    return convert(finalRed, finalGreen, finalBlue);
  }

  //      
  var namedColorMap = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '639',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32'
  };

  /**
   * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
   * @private
   */
  function nameToHex(color) {
    if (typeof color !== 'string') return color;
    var normalizedColorName = color.toLowerCase();
    return namedColorMap[normalizedColorName] ? '#' + namedColorMap[normalizedColorName] : color;
  }

  //      
  var hexRegex = /^#[a-fA-F0-9]{6}$/;
  var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
  var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
  var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/;
  var hslRegex = /^hsl\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*\)$/;
  var hslaRegex = /^hsla\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/;

  /**
   * Returns an RgbColor or RgbaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a RgbColor or RgbaColor object back to a string.
   *
   * @example
   * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
   * const color1 = 'rgb(255, 0, 0)';
   * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
   * const color2 = 'hsla(210, 10%, 40%, 0.75)';
   */
  function parseToRgb(color) {
    if (typeof color !== 'string') {
      throw new Error('Passed an incorrect argument to a color function, please pass a string representation of a color.');
    }
    var normalizedColor = nameToHex(color);
    if (normalizedColor.match(hexRegex)) {
      return {
        red: parseInt('' + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt('' + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt('' + normalizedColor[5] + normalizedColor[6], 16)
      };
    }
    if (normalizedColor.match(reducedHexRegex)) {
      return {
        red: parseInt('' + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt('' + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt('' + normalizedColor[3] + normalizedColor[3], 16)
      };
    }
    var rgbMatched = rgbRegex.exec(normalizedColor);
    if (rgbMatched) {
      return {
        red: parseInt('' + rgbMatched[1], 10),
        green: parseInt('' + rgbMatched[2], 10),
        blue: parseInt('' + rgbMatched[3], 10)
      };
    }
    var rgbaMatched = rgbaRegex.exec(normalizedColor);
    if (rgbaMatched) {
      return {
        red: parseInt('' + rgbaMatched[1], 10),
        green: parseInt('' + rgbaMatched[2], 10),
        blue: parseInt('' + rgbaMatched[3], 10),
        alpha: parseFloat('' + rgbaMatched[4])
      };
    }
    var hslMatched = hslRegex.exec(normalizedColor);
    if (hslMatched) {
      var hue = parseInt('' + hslMatched[1], 10);
      var saturation = parseInt('' + hslMatched[2], 10) / 100;
      var lightness = parseInt('' + hslMatched[3], 10) / 100;
      var rgbColorString = 'rgb(' + hslToRgb(hue, saturation, lightness) + ')';
      var hslRgbMatched = rgbRegex.exec(rgbColorString);
      return {
        red: parseInt('' + hslRgbMatched[1], 10),
        green: parseInt('' + hslRgbMatched[2], 10),
        blue: parseInt('' + hslRgbMatched[3], 10)
      };
    }
    var hslaMatched = hslaRegex.exec(normalizedColor);
    if (hslaMatched) {
      var _hue = parseInt('' + hslaMatched[1], 10);
      var _saturation = parseInt('' + hslaMatched[2], 10) / 100;
      var _lightness = parseInt('' + hslaMatched[3], 10) / 100;
      var _rgbColorString = 'rgb(' + hslToRgb(_hue, _saturation, _lightness) + ')';
      var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
      return {
        red: parseInt('' + _hslRgbMatched[1], 10),
        green: parseInt('' + _hslRgbMatched[2], 10),
        blue: parseInt('' + _hslRgbMatched[3], 10),
        alpha: parseFloat('' + hslaMatched[4])
      };
    }
    throw new Error("Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.");
  }

  //      


  function rgbToHsl(color) {
    // make sure rgb are contained in a set of [0, 255]
    var red = color.red / 255;
    var green = color.green / 255;
    var blue = color.blue / 255;

    var max = Math.max(red, green, blue);
    var min = Math.min(red, green, blue);
    var lightness = (max + min) / 2;

    if (max === min) {
      // achromatic
      if (color.alpha !== undefined) {
        return { hue: 0, saturation: 0, lightness: lightness, alpha: color.alpha };
      } else {
        return { hue: 0, saturation: 0, lightness: lightness };
      }
    }

    var hue = void 0;
    var delta = max - min;
    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case red:
        hue = (green - blue) / delta + (green < blue ? 6 : 0);
        break;
      case green:
        hue = (blue - red) / delta + 2;
        break;
      default:
        // blue case
        hue = (red - green) / delta + 4;
        break;
    }

    hue *= 60;
    if (color.alpha !== undefined) {
      return { hue: hue, saturation: saturation, lightness: lightness, alpha: color.alpha };
    }
    return { hue: hue, saturation: saturation, lightness: lightness };
  }

  //      

  /**
   * Returns an HslColor or HslaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a HslColor or HslaColor object back to a string.
   *
   * @example
   * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
   * const color1 = 'rgb(255, 0, 0)';
   * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
   * const color2 = 'hsla(210, 10%, 40%, 0.75)';
   */
  function parseToHsl(color) {
    // Note: At a later stage we can optimize this function as right now a hsl
    // color would be parsed converted to rgb values and converted back to hsl.
    return rgbToHsl(parseToRgb(color));
  }

  //      

  /**
   * Reduces hex values if possible e.g. #ff8866 to #f86
   * @private
   */
  var reduceHexValue = function reduceHexValue(value) {
    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
      return "#" + value[1] + value[3] + value[5];
    }
    return value;
  };

  //      
  function numberToHex(value) {
    var hex = value.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }

  //      

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgb(255, 205, 100),
   *   background: rgb({ red: 255, green: 205, blue: 100 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgb(255, 205, 100)};
   *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffcd64";
   *   background: "#ffcd64";
   * }
   */
  function rgb(value, green, blue) {
    if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
      return reduceHexValue('#' + numberToHex(value) + numberToHex(green) + numberToHex(blue));
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && green === undefined && blue === undefined) {
      return reduceHexValue('#' + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
    }

    throw new Error('Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).');
  }

  //      

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: rgba(255, 205, 100, 0.7),
   *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
   *   background: rgba(255, 205, 100, 1),
   *   background: rgba('#ffffff', 0.4),
   *   background: rgba('black', 0.7),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${rgba(255, 205, 100, 0.7)};
   *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
   *   background: ${rgba(255, 205, 100, 1)};
   *   background: ${rgba('#ffffff', 0.4)};
   *   background: ${rgba('black', 0.7)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(255,205,100,0.7)";
   *   background: "rgba(255,205,100,0.7)";
   *   background: "#ffcd64";
   *   background: "rgba(255,255,255,0.4)";
   *   background: "rgba(0,0,0,0.7)";
   * }
   */
  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue === 'string' && typeof secondValue === 'number') {
      var rgbValue = parseToRgb(firstValue);
      return 'rgba(' + rgbValue.red + ',' + rgbValue.green + ',' + rgbValue.blue + ',' + secondValue + ')';
    } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
      return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : 'rgba(' + firstValue + ',' + secondValue + ',' + thirdValue + ',' + fourthValue + ')';
    } else if ((typeof firstValue === 'undefined' ? 'undefined' : _typeof(firstValue)) === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
      return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : 'rgba(' + firstValue.red + ',' + firstValue.green + ',' + firstValue.blue + ',' + firstValue.alpha + ')';
    }

    throw new Error('Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).');
  }

  //      
  function colorToHex(color) {
    return numberToHex(Math.round(color * 255));
  }

  function convertToHex(red, green, blue) {
    return reduceHexValue('#' + colorToHex(red) + colorToHex(green) + colorToHex(blue));
  }

  function hslToHex(hue, saturation, lightness) {
    return hslToRgb(hue, saturation, lightness, convertToHex);
  }

  //      

  /**
   * Returns a string value for the color. The returned result is the smallest possible hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsl(359, 0.75, 0.4),
   *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsl(359, 0.75, 0.4)};
   *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#b3191c";
   *   background: "#b3191c";
   * }
   */
  function hsl(value, saturation, lightness) {
    if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
      return hslToHex(value, saturation, lightness);
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && saturation === undefined && lightness === undefined) {
      return hslToHex(value.hue, value.saturation, value.lightness);
    }

    throw new Error('Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).');
  }

  //      

  /**
   * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: hsla(359, 0.75, 0.4, 0.7),
   *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
   *   background: hsla(359, 0.75, 0.4, 1),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${hsla(359, 0.75, 0.4, 0.7)};
   *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
   *   background: ${hsla(359, 0.75, 0.4, 1)};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "rgba(179,25,28,0.7)";
   *   background: "rgba(179,25,28,0.7)";
   *   background: "#b3191c";
   * }
   */
  function hsla(value, saturation, lightness, alpha) {
    if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
      return alpha >= 1 ? hslToHex(value, saturation, lightness) : 'rgba(' + hslToRgb(value, saturation, lightness) + ',' + alpha + ')';
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
      return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : 'rgba(' + hslToRgb(value.hue, value.saturation, value.lightness) + ',' + value.alpha + ')';
    }

    throw new Error('Passed invalid arguments to hsla, please pass multiple numbers e.g. hsl(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).');
  }

  //      
  var isRgb = function isRgb(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };

  var isRgba = function isRgba(color) {
    return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
  };

  var isHsl = function isHsl(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
  };

  var isHsla = function isHsla(color) {
    return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
  };

  var errMsg = 'Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.';

  /**
   * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
   * This util is useful in case you only know on runtime which color object is
   * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: toColorString({ red: 255, green: 205, blue: 100 }),
   *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
   *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
   *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
   *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
   *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
   *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
   * `
   *
   * // CSS in JS Output
   * element {
   *   background: "#ffcd64";
   *   background: "rgba(255,205,100,0.72)";
   *   background: "#00f";
   *   background: "rgba(179,25,25,0.72)";
   * }
   */

  function toColorString(color) {
    if ((typeof color === 'undefined' ? 'undefined' : _typeof(color)) !== 'object') throw new Error(errMsg);
    if (isRgba(color)) return rgba(color);
    if (isRgb(color)) return rgb(color);
    if (isHsla(color)) return hsla(color);
    if (isHsl(color)) return hsl(color);

    throw new Error(errMsg);
  }

  //      

  // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js


  // eslint-disable-next-line no-unused-vars


  // eslint-disable-next-line no-unused-vars

  // eslint-disable-next-line no-redeclare


  function curried(f, length, acc) {
    return function fn() {
      // eslint-disable-next-line prefer-rest-params
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
    };
  }

  // eslint-disable-next-line no-redeclare
  function curry(f) {
    // eslint-disable-line no-redeclare
    return curried(f, f.length, []);
  }

  //      

  function guard(lowerBoundary, upperBoundary, value) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value));
  }

  //      

  /**
   * Returns a string value for the darkened color.
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: darken(0.2, '#FFCD64'),
   *   background: darken(0.2, 'rgba(255,205,100,0.7)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${darken(0.2, '#FFCD64')};
   *   background: ${darken(0.2, 'rgba(255,205,100,0.7)')};
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#ffbd31";
   *   background: "rgba(255,189,49,0.7)";
   * }
   */
  function darken(amount, color) {
    var hslColor = parseToHsl(color);
    return toColorString(_extends$3({}, hslColor, {
      lightness: guard(0, 1, hslColor.lightness - amount)
    }));
  }

  var curriedDarken = /*#__PURE__*/curry(darken);

  var getDarker = curriedDarken(0.2);

  var mapPropsToStyles$8 = function mapPropsToStyles(props) {
    // TODO: fix color here
    var color = props.primary ? props.theme.vars['--primary-color'] : 'black';
    var darkerColor = getDarker(color);
    return {
      borderColor: color,
      color: color,
      ':hover': {
        color: darkerColor,
        borderColor: darkerColor
      }
    };
  };

  var StyledButton$1 =
  /*#__PURE__*/
  styled$1(function (_ref) {
    var href = _ref.href,
        props = _objectWithoutPropertiesLoose(_ref, ["href"]);

    if (!href) {
      return React.createElement("button", props);
    }

    return React.createElement("a", _extends({
      href: href,
      rel: "nofollow noopener"
    }, props));
  }, {
    displayName: 'Button',
    mapPropsToStyles: mapPropsToStyles$8,
    shouldForwardProp: index,
    target: "e1972fzd0"
  })("border-width:1px;border-style:solid;background-color:#fff;font-size:1em;font-family:inherit;text-align:center;text-decoration:none;appearance:none;padding:0.8em;transition:box-shadow 0.1s,color 0.1s,border-color 0.2s;&:hover{cursor:pointer;}&:active{box-shadow:none;outline:none;}&:focus{box-shadow:none;outline:none;}&[disabled]{pointer-events:none;}");

  var Button = function Button(_ref2) {
    var label = _ref2.label,
        props = _objectWithoutPropertiesLoose(_ref2, ["label"]);

    return React.createElement(StyledButton$1, props, label);
  };

  Button.propTypes = {
    /** Button's label */
    label: PropTypes.string
  };

  var StyledButton$2 =
  /*#__PURE__*/
  styled$1(Button, {
    target: "e121y1dq0"
  })("display:inline-block;width:100%;border-left:0;border-right:0;border-top:0;border-bottom-color:rgba(0,0,0,0.1);box-shadow:none;transition:background-color 0.1s;background:transparent;color:", function (props) {
    return props.disabled ? '#8D9BA9' : 'inherit';
  }, ";margin:0;&:hover{border-bottom-color:rgba(0,0,0,0.15);background:rgba(0,0,0,0.02);color:inherit;}&:active{background:rgba(0,0,0,0.04);color:inherit;}");

  var MessageButton =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(MessageButton, _React$Component);

    function MessageButton() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this.handleClick = function (event) {
        event.stopPropagation();

        _this.props.onClick(event);
      };

      return _this;
    }

    var _proto = MessageButton.prototype;

    _proto.render = function render() {
      return React.createElement(StyledButton$2, _extends({}, this.props, {
        onClick: this.handleClick
      }));
    };

    return MessageButton;
  }(React.Component);

  MessageButton.propTypes = {
    className: PropTypes.string,

    /** Button's label */
    label: PropTypes.string,
    onClick: PropTypes.func,
    primary: PropTypes.bool,

    /** Button's value */
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  };
  MessageButton.defaultProps = {
    onClick: noop
  };

  var compactChildren = function compactChildren(children) {
    return React.Children.toArray(children).filter(Boolean);
  };
  var hasControlledProps = function hasControlledProps(controlledList, ownProps) {
    return values(pick(controlledList, ownProps)).filter(function (prop) {
      return prop !== undefined;
    }).length > 0;
  };

  var SINGLE = {
    radiusType: 'single'
  };
  var FIRST = {
    radiusType: 'first'
  };
  var LAST = {
    radiusType: 'last'
  };
  var hideMetaProps = {
    authorName: null,
    date: null
  };

  var mapPropsToStyles$9 = function mapPropsToStyles(props) {
    if (props.isOwn) {
      return {
        flexDirection: 'row-reverse'
      };
    }

    return null;
  };

  var StyledGroup =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'MessageGroup',
    mapPropsToStyles: mapPropsToStyles$9,
    target: "eslhdd60"
  })("display:flex;margin-bottom:1em;");
  var AvatarWrapper =
  /*#__PURE__*/
  styled$1('div', {
    target: "eslhdd61"
  })("display:flex;flex-direction:column;align-items:center;text-align:center;font-size:0.7em;line-height:1.6em;", function (props) {
    return {
      minWidth: props.theme.Avatar.size,
      margin: props.isOwn ? '0 0 0 .3em' : '0 .3em 0 0'
    };
  }, ";");
  var messageGropContainerStyle =
  /*#__PURE__*/
  css("overflow:hidden;");

  var MessageGroup = function MessageGroup(_ref) {
    var avatar = _ref.avatar,
        avatarLetter = _ref.avatarLetter,
        children = _ref.children,
        onlyFirstWithMeta = _ref.onlyFirstWithMeta,
        props = _objectWithoutPropertiesLoose(_ref, ["avatar", "avatarLetter", "children", "onlyFirstWithMeta"]);

    var compactedChildren = compactChildren(children);
    var childrenCount = React.Children.count(compactedChildren);
    return React.createElement(StyledGroup, props, (avatar || avatarLetter) && React.createElement(AvatarWrapper, {
      flexFit: true,
      isOwn: props.isOwn
    }, React.createElement(Avatar, {
      imgUrl: avatar,
      letter: avatarLetter
    })), React.createElement(Fill, {
      className: messageGropContainerStyle
    }, React.Children.map(compactedChildren, function (child, index) {
      if (childrenCount === 1) {
        return React.cloneElement(child, SINGLE);
      }

      if (index === 0) {
        return React.cloneElement(child, FIRST);
      }

      var hideMeta = onlyFirstWithMeta && index > 0;

      if (index === childrenCount - 1) {
        return React.cloneElement(child, hideMeta ? _extends({}, LAST, hideMetaProps) : LAST);
      }

      return hideMeta ? React.cloneElement(child, hideMetaProps) : child;
    })));
  };

  MessageGroup.propTypes = {
    /** Message author's avatar URL */
    avatar: PropTypes.string,

    /** Message author's initials (if no URL is passed) */
    avatarLetter: PropTypes.string,

    /** Component's children nodes - i.e. Message components */
    children: PropTypes.node,

    /** Message author - agent (left side) or visitor (right side) */
    isOwn: PropTypes.bool,
    onlyFirstWithMeta: PropTypes.bool
  };

  var darkTheme = {
    vars: {
      'primary-color': '#0d449b',
      'secondary-color': '#3a3a3a',
      'tertiary-color': 'rgba(0, 0, 0, 0.8)'
    },
    AgentBar: {
      css: {
        color: '#fff'
      },
      IconButton: {
        css: {
          background: 'rgba(0, 0, 0, 0.2)',
          borderRadius: '50%',
          padding: '1em',
          margin: '.3em'
        }
      },
      Icon: {
        css: {
          transform: 'scale(0.7)'
        }
      }
    },
    Bubble: {
      css: {
        color: '#fff'
      }
    },
    TitleBar: {
      css: {
        background: '#3a3a3a',
        borderRadius: '1.2em 1.2em 0 0',
        padding: '.5em'
      }
    },
    FixedWrapperMaximized: {
      css: {
        borderRadius: '1.2em',
        overflow: 'hidden',
        height: '660px'
      }
    },
    Message: {
      secondaryTextColor: '#fff'
    },
    TextComposer: {
      css: {
        background: '#eaeaea'
      }
    },
    TextInput: {
      css: {
        background: '#eaeaea'
      }
    }
  };

  var purpleTheme = {
    vars: {
      'primary-color': '#6D5BBA',
      'secondary-color': '#3a3a3a',
      'tertiary-color': 'rgba(0, 0, 0, 0.8)'
    },
    Avatar: {
      size: '20px',
      css: {
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    AgentBar: {
      css: {
        color: '#fff',
        background: 'linear-gradient(to right, #6D5BBA, #8D58BF)',
        borderRadius: '.5em',
        marginBottom: '.7em',
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    TitleBar: {
      css: {
        background: 'transparent',
        borderRadius: '.5em',
        marginBottom: '.5em',
        padding: '0'
      },
      IconButton: {
        css: {
          background: 'linear-gradient(to right, #6D5BBA, #8D58BF)',
          borderRadius: '8px',
          padding: '1em',
          margin: '.3em',
          boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
        }
      }
    },
    MessageList: {
      css: {
        background: 'linear-gradient(to right, #6D5BBA, #8D58BF)',
        marginBottom: '.7em',
        borderRadius: '.5em',
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    TextComposer: {
      css: {
        borderRadius: '.5em',
        marginBottom: '.7em',
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    Message: {
      secondaryTextColor: '#fff',
      own: {
        Bubble: {
          css: {
            color: '#fff',
            background: '#AA8BD2'
          }
        }
      }
    },
    Bubble: {
      ovalBorderRadius: '.4em',
      sharpBorderRadius: '.4em',
      css: {
        color: '#5A6976',
        background: '#fff',
        fontSize: '14px'
      }
    },
    FixedWrapperMaximized: {
      css: {
        width: '280px'
      }
    }
  };

  var elegantTheme = {
    vars: {
      'primary-color': '#5A6976'
    },
    Avatar: {
      size: '20px',
      css: {
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    FixedWrapperMaximized: {
      css: {
        width: '310px',
        borderRadius: 0,
        boxShadow: '0 .1em 1em rgba(0, 0, 0, 0.3)'
      }
    },
    AgentBar: {
      css: {
        color: '#000',
        background: '#fff'
      },
      Avatar: {
        css: {
          boxShadow: 'none'
        }
      }
    },
    TitleBar: {
      css: {
        color: '#000',
        background: '#fff'
      },
      Icon: {
        color: '#D9A646'
      }
    },
    MessageList: {
      css: {
        background: 'rgba(0, 0, 0, 0.8)'
      }
    },
    Bubble: {
      sharpBorderRadius: '.4em',
      ovalBorderRadius: '.4em'
    }
  };

  var LIGHT_BLUE = '#427fe1';
  var WHITE = '#fff';
  var defaultTheme = {
    vars: {
      'primary-color': LIGHT_BLUE,
      'secondary-color': '#fbfbfb',
      'tertiary-color': WHITE
    },
    AgentBar: {
      Avatar: {
        size: '42px',
        css: {
          marginRight: '.6em'
        }
      },
      css: {
        backgroundColor: 'var(--secondary-color)'
      }
    },
    Avatar: {
      size: '30px'
    },
    Bubble: {
      sharpBorderRadius: '0.3em',
      ovalBorderRadius: '1.4em',
      css: {
        backgroundColor: {
          "default": 'var(--secondary-color)',
          bot: 'green'
        }
      }
    },
    Button: {},
    ChatListItem: {
      Avatar: {
        css: {
          marginRight: '.5em'
        }
      }
    },
    FixedWrapperMaximized: {
      animationDuration: 100,
      width: '400px',
      height: '500px'
    },
    FixedWrapperMinimized: {
      animationDuration: 100
    },
    FixedWrapperRoot: {
      position: 'right',
      css: {}
    },
    Message: {
      secondaryTextColor: '#000',
      horizontalAlign: 'left',
      own: {
        horizontalAlign: 'right',
        Bubble: {
          css: {
            backgroundColor: 'var(--primary-color)',
            color: WHITE
          }
        },
        Content: {
          css: {
            alignItems: 'flex-end'
          }
        },
        MessageMeta: {
          css: {
            textAlign: 'right'
          }
        },
        Time: {
          css: {
            textAlign: 'right'
          }
        }
      },
      bot: {
        Bubble: {
          css: {
            backgroundColor: 'green'
          }
        }
      }
    },
    MessageButtons: {},
    MessageGroup: {},
    MessageList: {
      css: {
        backgroundColor: 'var(--tertiary-color)'
      }
    },
    MessageMedia: {},
    MessageText: {},
    MessageTitle: {},
    QuickReply: {
      css: {
        borderColor: 'var(--primary-color)',
        backgroundColor: '#fff',
        color: 'var(--primary-color)'
      }
    },
    TextComposer: {
      // TODO: this is a color for text, but sounds like a color for background
      inputColor: '#000',
      Icon: {
        color: '#aaa'
      },
      IconButton: {
        active: {
          Icon: {
            color: 'var(--primary-color)'
          }
        }
      }
    },
    TitleBar: {
      iconsColor: '#fff',
      behaviour: 'default',
      css: {
        backgroundColor: 'var(--primary-color)'
      }
    }
  };

  var parseTheme = function parseTheme(theme) {
    var componentKeys = pickComponentKeys(theme);

    if (Object.keys(componentKeys).length === 0) {
      return _extends({}, theme, {
        vars: mapKeys(function (key) {
          return "--" + key;
        }, theme.vars || {})
      });
    }

    return _extends({}, theme, mapValues(function (component) {
      return _extends({}, parseTheme(component), {
        css: component.css || {}
      });
    }, componentKeys), {
      vars: mapKeys(function (key) {
        return "--" + key;
      }, theme.vars || {})
    });
  };

  var TopLevelThemeProvider = function TopLevelThemeProvider(_ref) {
    var _ref$theme = _ref.theme,
        theme = _ref$theme === void 0 ? {} : _ref$theme,
        children = _ref.children;
    var parsed = parseTheme(merge(defaultTheme, theme));
    return React.createElement(ThemeProvider$1, {
      value: parsed
    }, children);
  };

  // TODO: hover states and such should be handled - tweak at least borderColor, and backgroundColor

  var StyledReply =
  /*#__PURE__*/
  styled$1('button', {
    displayName: 'QuickReply',
    target: "e1gt5po80"
  })("border-width:1px;border-style:solid;font-size:1em;line-height:1em;appearance:none;transition:box-shadow 0.1s,color 0.1s,border-color 0.2s;margin:0.25em;background-color:#fff;border-radius:1.4em;box-shadow:0 0.1em 0.1em 0 rgba(32,34,40,0.05);font-weight:400;overflow:hidden;padding:0.375em 1em 0.5em;word-break:break-word;&:hover{cursor:pointer;}&:active,&:focus{box-shadow:none;outline:none;background-color:rgba(0,0,0,0.05);}");

  var QuickReply =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(QuickReply, _React$Component);

    function QuickReply() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this._handleClick = function (event) {
        // TODO: discuss during review - button already has native value
        // QuickReply might not need onSelect, just onClick, and one can read the value by accessing event.target.value
        // QuickReplies OTOH needs onSelect
        _this.props.onSelect(_this.props.value);

        _this.props.onClick(event);
      };

      return _this;
    }

    var _proto = QuickReply.prototype;

    _proto.render = function render() {
      return React.createElement(StyledReply, _extends({}, this.props, {
        onClick: this._handleClick
      }));
    };

    return QuickReply;
  }(React.Component);

  QuickReply.defaultProps = {
    onClick: noop,
    onSelect: noop
  };
  QuickReply.propTypes = {
    children: PropTypes.node.isRequired,
    onClick: PropTypes.func,
    onSelect: PropTypes.func,
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  };

  // eslint-disable-next-line no-console

  var warnOnce$1 = once(console.warn.bind(console));
  var StyledReplies =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'QuickReplies',
    target: "e1dnb9qc0"
  })("display:flex;flex-wrap:wrap;text-align:center;justify-content:center;width:100%;");

  var QuickReplies =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(QuickReplies, _React$Component);

    function QuickReplies() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this._handleSelect = function (value) {
        return _this.props.onSelect(value);
      };

      return _this;
    }

    var _proto = QuickReplies.prototype;

    _proto.render = function render() {
      var _this2 = this;

      // eslint-disable-next-line no-unused-vars
      var _this$props = this.props,
          children = _this$props.children,
          replies = _this$props.replies,
          onSelect = _this$props.onSelect,
          props = _objectWithoutPropertiesLoose(_this$props, ["children", "replies", "onSelect"]);

      if (children && replies) {
        // eslint-disable-next-line no-console
        warnOnce$1(['You should not use replies & children props together.', 'They cannot be rendered at once - children prop has higher rendering priority.'].join('\n'));
      }

      var childs = children ? compactChildren(children) : replies.map(function (reply, index) {
        return React.createElement(QuickReply, {
          key: index,
          value: reply
        }, reply);
      });
      return React.createElement(StyledReplies, props, React.Children.map(childs, function (child) {
        return React.cloneElement(child, {
          onSelect: _this2._handleSelect
        });
      }));
    };

    return QuickReplies;
  }(React.Component);

  QuickReplies.defaultProps = {
    onSelect: noop
  };
  QuickReplies.propTypes = {
    children: PropTypes.node,
    onSelect: PropTypes.func,
    replies: PropTypes.arrayOf(PropTypes.string)
  };

  var StyledBar$1 =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'TitleBar',
    section: true,
    target: "e1ohfhv0"
  })("display:flex;justify-content:center;align-items:center;width:100%;border:#000;color:#fff;position:relative;z-index:2;text-align:center;padding:0.4em;");
  var Title$1 =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'TitleBarTitle',
    target: "e1ohfhv1"
  })("width:100%;margin:0;margin-bottom:4px;padding:0 2px;text-align:center;font-size:0.9em;flex-grow:1;");

  var TitleBar = function TitleBar(_ref) {
    var leftIcons = _ref.leftIcons,
        rightIcons = _ref.rightIcons,
        title = _ref.title,
        props = _objectWithoutPropertiesLoose(_ref, ["leftIcons", "rightIcons", "title"]);

    return React.createElement(StyledBar$1, props, leftIcons, React.createElement(Title$1, {
      ellipsis: true
    }, title), rightIcons);
  };

  TitleBar.propTypes = {
    leftIcons: PropTypes.arrayOf(PropTypes.node),
    rightIcons: PropTypes.arrayOf(PropTypes.node),
    theme: PropTypes.shape(),
    title: PropTypes.string
  };

  var _React$createContext$1 = React.createContext(),
      ComposerProvider = _React$createContext$1.Provider,
      ComposerSpy = _React$createContext$1.Consumer;
  var StyledComposer =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'TextComposer',
    section: true,
    target: "eyij3xx0"
  })("padding:0.5em;background:#fff;border-top:1px solid rgba(0,0,0,0.1);");

  var TextComposer =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(TextComposer, _React$Component);

    function TextComposer() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.state = {
        value: _this._getValue({
          value: _this.props.defaultValue
        })
      };

      _this._handleButtonClick = function (event) {
        var sent = _this.maybeSend();

        if (!sent) {
          return;
        }

        _this.props.onButtonClick(event);
      };

      _this._handleChange = function (event) {
        var value = event.target.value;

        if (!_this._isControlled()) {
          _this.setState({
            value: value
          });
        }

        _this.props.onValueChange(value);

        _this.props.onChange(event);
      };

      _this._handleInputRef = function (ref) {
        _this._inputRef = ref;

        _this.props.inputRef(ref);
      };

      _this._handleKeyDown = function (event) {
        var onKeyDown = _this.props.onKeyDown;

        if (wasOnlyEnterPressed(event)) {
          event.preventDefault();
        }

        if (!wasEnterPressed(event) || wasNewLineIntended(event)) {
          onKeyDown(event);
          return;
        }

        _this.maybeSend();

        onKeyDown(event);
      };

      _this.maybeSend = function () {
        if (!_this._canSend()) {
          return false;
        }

        if (!_this._isControlled()) {
          _this.setState({
            value: ''
          });
        }

        _this.props.onValueChange('');

        _this.props.onSend(trimEnd(_this.state.value));

        return true;
      };

      return _this;
    }

    var _proto = TextComposer.prototype;

    _proto._getValue = function _getValue(state, props) {
      if (state === void 0) {
        state = this.state;
      }

      if (props === void 0) {
        props = this.props;
      }

      return this._isControlled() ? props.value : state.value;
    };

    _proto._canSend = function _canSend() {
      return this.props.active && this.state.value.trim() !== '';
    };

    _proto._isControlled = function _isControlled() {
      return this.props.value === 'string';
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      var value = this._getValue();

      var prevValue = this._getValue(prevState, prevProps);

      if (value !== prevValue && value === '') {
        this._inputRef.focus();
      }
    };

    _proto.render = function render() {
      // eslint-disable-next-line no-unused-vars
      var _this$props = this.props,
          active = _this$props.active,
          children = _this$props.children,
          defaultValue = _this$props.defaultValue,
          onButtonClick = _this$props.onButtonClick,
          onChange = _this$props.onChange,
          onKeyDown = _this$props.onKeyDown,
          onSend = _this$props.onSend,
          onValueChange = _this$props.onValueChange,
          value = _this$props.value,
          props = _objectWithoutPropertiesLoose(_this$props, ["active", "children", "defaultValue", "onButtonClick", "onChange", "onKeyDown", "onSend", "onValueChange", "value"]);

      var contextValue = {
        active: this._canSend(),
        inputRef: this._handleInputRef,
        value: this._getValue(),
        maybeSend: this.maybeSend,
        onButtonClick: this._handleButtonClick,
        onChange: this._handleChange,
        onKeyDown: this._handleKeyDown
      };
      return React.createElement(ComposerProvider, {
        value: contextValue
      }, React.createElement(StyledComposer, props, children));
    };

    return TextComposer;
  }(React.Component);

  TextComposer.propTypes = {
    active: PropTypes.bool,
    children: PropTypes.node,
    defaultValue: PropTypes.string,
    inputRef: PropTypes.func,
    onButtonClick: PropTypes.func,
    onChange: PropTypes.func,
    onKeyDown: PropTypes.func,
    onSend: PropTypes.func,
    value: PropTypes.string
  };
  TextComposer.defaultProps = {
    active: true,
    defaultValue: '',
    inputRef: noop,
    onButtonClick: noop,
    onChange: noop,
    onKeyDown: noop,
    onSend: noop,
    onValueChange: noop
  };

  var withComposer = (function (mapComposerToProps) {
    if (mapComposerToProps === void 0) {
      mapComposerToProps = identity;
    }

    return function (WrappedComponent) {
      var _class, _temp;

      return _temp = _class =
      /*#__PURE__*/
      function (_React$Component) {
        _inheritsLoose$1(WithComposer, _React$Component);

        function WithComposer() {
          return _React$Component.apply(this, arguments) || this;
        }

        var _proto = WithComposer.prototype;

        _proto.render = function render() {
          var _this = this;

          return React.createElement(ComposerSpy, null, function (context) {
            return React.createElement(WrappedComponent, _extends({}, _this.props, mapComposerToProps(context, _this.props)));
          });
        };

        return WithComposer;
      }(React.Component), _class.displayName = "withComposer(" + getDisplayName(WrappedComponent) + ")", _temp;
    };
  });

  var mapPropsToStyles$a = function mapPropsToStyles(_ref) {
    var color = _ref.color;

    if (!color) {
      return null;
    }

    return {
      fill: color,
      '& *': {
        fill: color
      }
    };
  };

  var createStyledIcon = memoize$1(function (Icon) {
    return (
      /*#__PURE__*/
      styled$1(Icon, {
        displayType: 'Icon',
        mapPropsToStyles: mapPropsToStyles$a,
        shouldForwardProp: index,
        target: "e5ibypu0"
      })("&{display:block;}&,& *{fill:currentColor;}")
    );
  });

  var Icon = function Icon(_ref2) {
    var children = _ref2.children,
        props = _objectWithoutPropertiesLoose(_ref2, ["children"]);

    var StyledIcon = createStyledIcon(children.type);
    return React.createElement(StyledIcon, props);
  };

  Icon.propTypes = {
    children: PropTypes.node.isRequired
  };

  var Send = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      height: "18px",
      viewBox: "0 0 21 18",
      width: "21px"
    }, props), React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd",
      stroke: "none",
      strokeWidth: "1"
    }, React__default.createElement("g", {
      fill: "#000000"
    }, React__default.createElement("polygon", {
      points: "0.01 18 21 9 0.01 0 0 7 15 9 0 11"
    }))));
  });

  var SendIcon = function SendIcon(props) {
    return React.createElement(Icon, props, React.createElement(Send, null));
  };

  var SendButton =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(SendButton, _React$Component);

    function SendButton() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = SendButton.prototype;

    _proto.render = function render() {
      var _this$props = this.props,
          icon = _this$props.icon,
          restProps = _objectWithoutPropertiesLoose(_this$props, ["icon"]);

      return React.createElement(StyledButton, restProps, icon ? React.createElement(Icon, null, icon) : React.createElement(SendIcon, null));
    };

    return SendButton;
  }(React.Component); // eslint-disable-next-line no-console


  SendButton.propTypes = {
    active: PropTypes.bool,
    onClick: PropTypes.func
  };
  var warnOnce$2 = once(console.warn.bind(console));
  var SendButton$1 = withComposer(function (_ref, ownProps) {
    var active = _ref.active,
        onButtonClick = _ref.onButtonClick;

    {
      var sendButtonProps = ['active', 'onClick'];

      if (hasControlledProps(sendButtonProps, ownProps)) {
        // eslint-disable-next-line no-console
        warnOnce$2([sendButtonProps + " props are controlled by TextComposer,", "if you want to use those please pass them to the TextComposer instead of " + getDisplayName(SendButton) + "."].join(' '));
      }
    }

    return active ? {
      active: active,
      onClick: onButtonClick
    } : {
      active: active
    };
  })(SendButton);

  var _isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

  var isIE = _isBrowser ? !!document.documentElement.currentStyle : false;
  var HIDDEN_TEXTAREA_STYLE = {
    'min-height': '0',
    'max-height': 'none',
    height: '0',
    visibility: 'hidden',
    overflow: 'hidden',
    position: 'absolute',
    'z-index': '-1000',
    top: '0',
    right: '0'
  };
  var SIZING_STYLE = ['letter-spacing', 'line-height', 'font-family', 'font-weight', 'font-size', 'font-style', 'tab-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left', 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width', 'box-sizing'];
  var computedStyleCache = {};
  var hiddenTextarea = (_isBrowser) && document.createElement('textarea');

  var forceHiddenStyles = function forceHiddenStyles(node) {
    Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {
      node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');
    });
  };

  if (_isBrowser) {
    forceHiddenStyles(hiddenTextarea);
  }

  function calculateNodeHeight(uiTextNode, uid, useCache, minRows, maxRows) {
    if (useCache === void 0) {
      useCache = false;
    }

    if (minRows === void 0) {
      minRows = null;
    }

    if (maxRows === void 0) {
      maxRows = null;
    }

    if (hiddenTextarea.parentNode === null) {
      document.body.appendChild(hiddenTextarea);
    } // Copy all CSS properties that have an impact on the height of the content in
    // the textbox


    var nodeStyling = calculateNodeStyling(uiTextNode, uid, useCache);

    if (nodeStyling === null) {
      return null;
    }

    var paddingSize = nodeStyling.paddingSize,
        borderSize = nodeStyling.borderSize,
        boxSizing = nodeStyling.boxSizing,
        sizingStyle = nodeStyling.sizingStyle; // Need to have the overflow attribute to hide the scrollbar otherwise
    // text-lines will not calculated properly as the shadow will technically be
    // narrower for content

    Object.keys(sizingStyle).forEach(function (key) {
      hiddenTextarea.style[key] = sizingStyle[key];
    });
    forceHiddenStyles(hiddenTextarea);
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || 'x';
    var minHeight = -Infinity;
    var maxHeight = Infinity;
    var height = hiddenTextarea.scrollHeight;

    if (boxSizing === 'border-box') {
      // border-box: add border, since height = content + padding + border
      height = height + borderSize;
    } else if (boxSizing === 'content-box') {
      // remove padding, since height = content
      height = height - paddingSize;
    } // measure height of a textarea with a single row


    hiddenTextarea.value = 'x';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize; // Stores the value's rows count rendered in `hiddenTextarea`,
    // regardless if `maxRows` or `minRows` props are passed

    var valueRowCount = Math.floor(height / singleRowHeight);

    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;

      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }

      height = Math.max(minHeight, height);
    }

    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;

      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }

      height = Math.min(maxHeight, height);
    }

    var rowCount = Math.floor(height / singleRowHeight);
    return {
      height: height,
      minHeight: minHeight,
      maxHeight: maxHeight,
      rowCount: rowCount,
      valueRowCount: valueRowCount
    };
  }

  function calculateNodeStyling(node, uid, useCache) {
    if (useCache === void 0) {
      useCache = false;
    }

    if (useCache && computedStyleCache[uid]) {
      return computedStyleCache[uid];
    }

    var style = window.getComputedStyle(node);

    if (style === null) {
      return null;
    }

    var sizingStyle = SIZING_STYLE.reduce(function (obj, name) {
      obj[name] = style.getPropertyValue(name);
      return obj;
    }, {});
    var boxSizing = sizingStyle['box-sizing']; // probably node is detached from DOM, can't read computed dimensions

    if (boxSizing === '') {
      return null;
    } // IE (Edge has already correct behaviour) returns content width as computed width
    // so we need to add manually padding and border widths


    if (isIE && boxSizing === 'border-box') {
      sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(style['border-right-width']) + parseFloat(style['border-left-width']) + parseFloat(style['padding-right']) + parseFloat(style['padding-left']) + 'px';
    }

    var paddingSize = parseFloat(sizingStyle['padding-bottom']) + parseFloat(sizingStyle['padding-top']);
    var borderSize = parseFloat(sizingStyle['border-bottom-width']) + parseFloat(sizingStyle['border-top-width']);
    var nodeInfo = {
      sizingStyle: sizingStyle,
      paddingSize: paddingSize,
      borderSize: borderSize,
      boxSizing: boxSizing
    };

    if (useCache) {
      computedStyleCache[uid] = nodeInfo;
    }

    return nodeInfo;
  }

  var purgeCache = function purgeCache(uid) {
    delete computedStyleCache[uid];
  };

  var noop$3 = function noop() {};

  var uid = 0;

  var TextareaAutosize =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(TextareaAutosize, _React$Component);

    function TextareaAutosize(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;

      _this._onRef = function (node) {
        _this._ref = node;
        var inputRef = _this.props.inputRef;

        if (typeof inputRef === 'function') {
          inputRef(node);
          return;
        }

        inputRef.current = node;
      };

      _this._onChange = function (event) {
        if (!_this._controlled) {
          _this._resizeComponent();
        }

        _this.props.onChange(event, _assertThisInitialized(_assertThisInitialized(_this)));
      };

      _this._resizeComponent = function (callback) {
        if (callback === void 0) {
          callback = noop$3;
        }

        if (!_this._ref) {
          callback();
          return;
        }

        var nodeHeight = calculateNodeHeight(_this._ref, _this._uid, _this.props.useCacheForDOMMeasurements, _this.props.minRows, _this.props.maxRows);

        if (nodeHeight === null) {
          callback();
          return;
        }

        var height = nodeHeight.height,
            minHeight = nodeHeight.minHeight,
            maxHeight = nodeHeight.maxHeight,
            rowCount = nodeHeight.rowCount,
            valueRowCount = nodeHeight.valueRowCount;
        _this.rowCount = rowCount;
        _this.valueRowCount = valueRowCount;

        if (_this.state.height !== height || _this.state.minHeight !== minHeight || _this.state.maxHeight !== maxHeight) {
          _this.setState({
            height: height,
            minHeight: minHeight,
            maxHeight: maxHeight
          }, callback);

          return;
        }

        callback();
      };

      _this.state = {
        height: props.style && props.style.height || 0,
        minHeight: -Infinity,
        maxHeight: Infinity
      };
      _this._uid = uid++;
      _this._controlled = props.value !== undefined;
      _this._resizeLock = false;
      return _this;
    }

    var _proto = TextareaAutosize.prototype;

    _proto.render = function render() {
      var _this$props = this.props,
          _inputRef = _this$props.inputRef,
          _maxRows = _this$props.maxRows,
          _minRows = _this$props.minRows,
          _onHeightChange = _this$props.onHeightChange,
          _useCacheForDOMMeasurements = _this$props.useCacheForDOMMeasurements,
          props = _objectWithoutPropertiesLoose(_this$props, ["inputRef", "maxRows", "minRows", "onHeightChange", "useCacheForDOMMeasurements"]);

      props.style = _extends({}, props.style, {
        height: this.state.height
      });
      var maxHeight = Math.max(props.style.maxHeight || Infinity, this.state.maxHeight);

      if (maxHeight < this.state.height) {
        props.style.overflow = 'hidden';
      }

      return React__default.createElement("textarea", _extends({}, props, {
        onChange: this._onChange,
        ref: this._onRef
      }));
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this2 = this;

      this._resizeComponent(); // Working around Firefox bug which runs resize listeners even when other JS is running at the same moment
      // causing competing rerenders (due to setState in the listener) in React.
      // More can be found here - facebook/react#6324


      this._resizeListener = function () {
        if (_this2._resizeLock) {
          return;
        }

        _this2._resizeLock = true;

        _this2._resizeComponent(function () {
          _this2._resizeLock = false;
        });
      };

      window.addEventListener('resize', this._resizeListener);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (prevProps !== this.props) {
        this._resizeComponent();
      }

      if (this.state.height !== prevState.height) {
        this.props.onHeightChange(this.state.height, this);
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      window.removeEventListener('resize', this._resizeListener);
      purgeCache(this._uid);
    };

    return TextareaAutosize;
  }(React__default.Component);

  TextareaAutosize.defaultProps = {
    inputRef: noop$3,
    onChange: noop$3,
    onHeightChange: noop$3,
    useCacheForDOMMeasurements: false
  };
  TextareaAutosize.propTypes = {
    inputRef: PropTypes__default.oneOfType([PropTypes__default.func, PropTypes__default.shape({
      current: PropTypes__default.any
    })]),
    maxRows: PropTypes__default.number,
    minRows: PropTypes__default.number,
    onChange: PropTypes__default.func,
    onHeightChange: PropTypes__default.func,
    style: PropTypes__default.object,
    useCacheForDOMMeasurements: PropTypes__default.bool,
    value: PropTypes__default.string
  };

  // TODO: we should have our own styled factory and this omit should be applied for each "global" custom prop
  // for wrapped custom React component

  var StyledInput =
  /*#__PURE__*/
  styled$1(function (_ref) {
    var flexFill = _ref.flexFill,
        props = _objectWithoutPropertiesLoose(_ref, ["flexFill"]);

    return React.createElement(TextareaAutosize, props);
  }, {
    displayName: 'TextInput',
    target: "e1m92qam0"
  })("apperance:none;border:0;resize:none;background-color:#fff;height:1.5em;line-height:1.5em;min-width 0;width:100%;font-size:1em;&:focus,&:active{outline:none;}");

  var TextInput =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(TextInput, _React$Component);

    function TextInput() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this._getRef = function (ref) {
        _this.props.inputRef(ref);

        _this.props.innerRef(ref);
      };

      return _this;
    }

    var _proto = TextInput.prototype;

    _proto.render = function render() {
      // eslint-disable-next-line no-unused
      var _this$props = this.props,
          innerRef = _this$props.innerRef,
          inputRef = _this$props.inputRef,
          props = _objectWithoutPropertiesLoose(_this$props, ["innerRef", "inputRef"]);

      return React.createElement(StyledInput, _extends({}, props, {
        inputRef: this._getRef
      }));
    };

    return TextInput;
  }(React.Component); // eslint-disable-next-line no-console


  TextInput.defaultProps = {
    innerRef: noop,
    inputRef: noop,
    maxRows: 3,
    onChange: noop,
    onKeyDown: noop,
    placeholder: 'Write a message...'
  };
  TextInput.propTypes = {
    defaultValue: PropTypes.string,
    innerRef: PropTypes.func,
    inputRef: PropTypes.func,
    maxRows: PropTypes.number,
    minRows: PropTypes.number,
    onChange: PropTypes.func,
    onHeightChange: PropTypes.func,
    onKeyDown: PropTypes.func,
    placeholder: PropTypes.string,
    value: PropTypes.string
  };
  var warnOnce$3 = once(console.warn.bind(console));
  var TextInput$1 = withComposer(function (_ref2, ownProps) {
    var inputRef = _ref2.inputRef,
        onChange = _ref2.onChange,
        onKeyDown = _ref2.onKeyDown,
        value = _ref2.value;

    {
      var textInputProps = ['defaultValue', 'inputRef', 'onChange', 'onKeyDown', 'value'];

      if (hasControlledProps(textInputProps, ownProps)) {
        // eslint-disable-next-line no-console
        warnOnce$3([textInputProps + " props are controlled by TextComposer,", "if you want to use those please pass them to the TextComposer instead of " + getDisplayName(TextInput) + "."].join(' '));
      }
    }

    return {
      inputRef: inputRef,
      onChange: onChange,
      onKeyDown: onKeyDown,
      value: value
    };
  })(TextInput);

  var mapPropsToStyles$b = function mapPropsToStyles(props) {
    var propsStyle = {};

    if (props.theme) {
      // TODO: should be done with nesting?
      propsStyle.right = props.theme.FixedWrapperRoot.position === 'right' ? '0' : 'auto';
      propsStyle.left = props.theme.FixedWrapperRoot.position === 'left' ? '0' : 'auto';
    }

    if (props.animationDuration) {
      propsStyle.transition = "all " + props.animationDuration + "ms ease-out";
    }

    if (props.state) {
      propsStyle.transform = props.state === 'entered' ? 'none' : 'scale(0.8) translate(10%, 30%)';
      propsStyle.opacity = props.state === 'entered' ? '1' : '0';
    }

    if (props.height) {
      propsStyle.height = props.height;
    }

    if (props.width) {
      propsStyle.width = props.width;
    }

    return propsStyle;
  };

  var StyledWrapper =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'FixedWrapperMaximized',
    mapPropsToStyles: mapPropsToStyles$b,
    target: "ep7mz240"
  })("display:flex;flex-direction:column;max-height:100vh;position:absolute;bottom:0;@media (max-width:490px){width:100%;height:100%;position:fixed;}");

  var FixedWrapperMaximized = function FixedWrapperMaximized(props) {
    return React.createElement(Transition, {
      "in": props.active,
      mountOnEnter: true,
      timeout: props.theme.FixedWrapperMaximized.animationDuration,
      unmountOnExit: true
    }, function (state) {
      return React.createElement(StyledWrapper, _extends({}, props, {
        state: state
      }), React.Children.map(props.children, function (child) {
        return React.cloneElement(child, {
          minimize: props.minimize
        });
      }));
    });
  };

  FixedWrapperMaximized.propTypes = {
    /** Component active - shown or hidden */
    active: PropTypes.bool,

    /** Content of the component, will have minimize function injected */
    children: PropTypes.node.isRequired,

    /** Method to change component's state from shown to hiden - passed by FixedWrapper.Root */
    minimize: PropTypes.func,

    /** Override component's styles */
    style: PropTypes.shape()
  };
  var Maximized = withTheme(FixedWrapperMaximized);

  var mapPropsToStyles$c = function mapPropsToStyles(_ref) {
    var state = _ref.state,
        theme = _ref.theme;
    var propsStyles = {};

    if (theme) {
      propsStyles.transition = "all " + theme.FixedWrapperMaximized.animationDuration + "ms ease-out"; // TODO could be done with nesting?

      propsStyles.right = theme.FixedWrapperRoot.position === 'right' ? '0' : 'auto';
      propsStyles.left = theme.FixedWrapperRoot.position === 'left' ? '0' : 'auto';
    }

    if (state) {
      propsStyles.transform = state === 'entered' ? 'none' : 'scale(0.8) translate(10%, 30%)';
      propsStyles.opacity = state === 'entered' ? '1' : '0';
    }

    return propsStyles;
  };

  var StyledWrapper$1 =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'FixedWrapperMinimized',
    mapPropsToStyles: mapPropsToStyles$c,
    target: "eq1nrcm0"
  })("width:60px;height:60px;position:absolute;bottom:1em;");

  var FixedWrapperMinimized = function FixedWrapperMinimized(props) {
    return React.createElement(Transition, {
      "in": props.active,
      mountOnEnter: true,
      timeout: props.theme.FixedWrapperMinimized.animationDuration,
      unmountOnExit: true
    }, function (state) {
      return React.createElement(StyledWrapper$1, _extends({}, props, {
        state: state
      }), React.Children.map(props.children, function (child) {
        return React.cloneElement(child, {
          maximize: props.maximize
        });
      }));
    });
  };

  FixedWrapperMinimized.propTypes = {
    /** Component active - shown or hidden */
    active: PropTypes.bool,

    /** Content of the component, will have maximize function injected */
    children: PropTypes.node.isRequired,

    /** Method to change component's state from shown to hiden - passed by FixedWrapper.Root */
    maximize: PropTypes.func,

    /** Override component's styles */
    style: PropTypes.shape()
  };
  var Minimized = withTheme(FixedWrapperMinimized);

  var mapPropsToStyles$d = function mapPropsToStyles(props) {
    var propsStyles = {};

    if (props.position === 'right') {
      propsStyles.right = '1em';
      propsStyles.left = 'auto';
    } else if (props.position === 'left') {
      propsStyles.right = 'auto';
      propsStyles.left = '1em';
    }

    return propsStyles;
  };

  var StyledWrapper$2 =
  /*#__PURE__*/
  styled$1('div', {
    displayName: 'FixedWrapperRoot',
    mapPropsToStyles: mapPropsToStyles$d,
    target: "e7t7c040"
  })("position:fixed;bottom:0;z-index:99;font-size:16px;");

  var FixedWrapperRoot = function FixedWrapperRoot(props) {
    return React.createElement(StyledWrapper$2, props, React.createElement(Toggle, {
      defaultOn: props.maximizedOnInit
    }, function (_ref) {
      var on = _ref.on,
          setOff = _ref.setOff,
          setOn = _ref.setOn;
      return React.createElement("div", null, React.Children.map(props.children, function (child) {
        if (child.type === Maximized) {
          return React.cloneElement(child, {
            minimize: setOff,
            active: on
          });
        }

        if (child.type === Minimized) {
          return React.cloneElement(child, {
            maximize: setOn,
            active: !on
          });
        }

        return child;
      }));
    }));
  };

  FixedWrapperRoot.defaultProps = {
    maximizedOnInit: false
  };
  FixedWrapperRoot.propTypes = {
    /** Content of the component. FixedWrapper.Maximized and FixedWrapper.Minimized components will receive the proper state and methods */
    children: PropTypes.node.isRequired,

    /** Show maximized component on init */
    maximizedOnInit: PropTypes.bool,

    /** Override component's styles */
    style: PropTypes.shape()
  };



  var FixedWrapperImport = /*#__PURE__*/Object.freeze({
    Root: FixedWrapperRoot,
    Maximized: Maximized,
    Minimized: Minimized
  });

  var FixedWrapper = FixedWrapperImport;

  var Add = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      height: "20px",
      viewBox: "0 0 20 20",
      width: "20px"
    }, props), React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd",
      stroke: "none",
      strokeWidth: "1"
    }, React__default.createElement("g", {
      fill: "#000000",
      fillRule: "nonzero"
    }, React__default.createElement("path", {
      d: "M10,0 C4.48,0 0,4.48 0,10 C0,15.52 4.48,20 10,20 C15.52,20 20,15.52 20,10 C20,4.48 15.52,0 10,0 Z M15,11 L11,11 L11,15 L9,15 L9,11 L5,11 L5,9 L9,9 L9,5 L11,5 L11,9 L15,9 L15,11 Z"
    }))));
  });

  var AddIcon = function AddIcon(props) {
    return React.createElement(Icon, props, React.createElement(Add, null));
  };

  var ArrowLeft = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "8px",
      height: "13px",
      viewBox: "0 0 8 13"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-840.000000, -560.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(845.000000, 567.000000) scale(-1, 1) translate(-845.000000, -567.000000) translate(831.000000, 553.000000)"
    }, React__default.createElement("g", {
      transform: "translate(3.000000, 1.000000)"
    }, React__default.createElement("polygon", {
      points: "8.59 17.34 13.17 12.75 8.59 8.16 10 6.75 16 12.75 10 18.75"
    }))))));
  });

  var ArrowLeftIcon = function ArrowLeftIcon(props) {
    return React.createElement(Icon, props, React.createElement(ArrowLeft, null));
  };

  var ArrowRight = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "8px",
      height: "13px",
      viewBox: "0 0 8 13"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-1104.000000, -560.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(1094.000000, 553.000000)"
    }, React__default.createElement("g", {
      transform: "translate(2.000000, 1.000000)"
    }, React__default.createElement("polygon", {
      points: "8.59 17.34 13.17 12.75 8.59 8.16 10 6.75 16 12.75 10 18.75"
    }))))));
  });

  var ArrowRightIcon = function ArrowRightIcon(props) {
    return React.createElement(Icon, props, React.createElement(ArrowRight, null));
  };

  var Attach = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "20px",
      height: "11px",
      viewBox: "0 0 20 11"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-1098.000000, -754.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(1096.000000, 747.000000)"
    }, React__default.createElement("path", {
      d: "M2,12.5 C2,9.46 4.46,7 7.5,7 L18,7 C20.21,7 22,8.79 22,11 C22,13.21 20.21,15 18,15 L9.5,15 C8.12,15 7,13.88 7,12.5 C7,11.12 8.12,10 9.5,10 L17,10 L17,12 L9.41,12 C8.86,12 8.86,13 9.41,13 L18,13 C19.1,13 20,12.1 20,11 C20,9.9 19.1,9 18,9 L7.5,9 C5.57,9 4,10.57 4,12.5 C4,14.43 5.57,16 7.5,16 L17,16 L17,18 L7.5,18 C4.46,18 2,15.54 2,12.5 Z"
    })))));
  });

  var AttachIcon = function AttachIcon(props) {
    return React.createElement(Icon, props, React.createElement(Attach, null));
  };

  var Chat = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "28px",
      height: "28px",
      viewBox: "0 0 28 28"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      fill: "#000000"
    }, React__default.createElement("path", {
      d: "M14,25.5 C12.4,25.5 10.8,25.2 9.4,24.7 L4.5,27.5 L4.5,21.9 C2,19.6 0.5,16.5 0.5,13 C0.5,6.1 6.5,0.5 14,0.5 C21.5,0.5 27.5,6.1 27.5,13 C27.5,19.9 21.5,25.5 14,25.5 L14,25.5 Z M9,11.5 C8.2,11.5 7.5,12.2 7.5,13 C7.5,13.8 8.2,14.5 9,14.5 C9.8,14.5 10.5,13.8 10.5,13 C10.5,12.2 9.8,11.5 9,11.5 L9,11.5 Z M14,11.5 C13.2,11.5 12.5,12.2 12.5,13 C12.5,13.8 13.2,14.5 14,14.5 C14.8,14.5 15.5,13.8 15.5,13 C15.5,12.2 14.8,11.5 14,11.5 L14,11.5 Z M19,11.5 C18.2,11.5 17.5,12.2 17.5,13 C17.5,13.8 18.2,14.5 19,14.5 C19.8,14.5 20.5,13.8 20.5,13 C20.5,12.2 19.8,11.5 19,11.5 L19,11.5 Z"
    }))));
  });

  var ChatIcon = function ChatIcon(props) {
    return React.createElement(Icon, props, React.createElement(Chat, null));
  };

  var CheckboxOff = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-861.000000, -556.000000)"
    }, React__default.createElement("g", {
      transform: "translate(861.000000, 556.000000)"
    }, React__default.createElement("g", null, React__default.createElement("rect", {
      stroke: "#BCC6D0",
      strokeWidth: "1",
      x: "0.5",
      y: "0.5",
      width: "15",
      height: "15",
      rx: "4",
      style: {
        fill: 'none'
      }
    }))))));
  });

  var CheckboxOffIcon = function CheckboxOffIcon(props) {
    return React.createElement(Icon, props, React.createElement(CheckboxOff, null));
  };

  var CheckboxOn = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-861.000000, -526.000000)"
    }, React__default.createElement("g", {
      transform: "translate(861.000000, 526.000000)"
    }, React__default.createElement("g", null, React__default.createElement("rect", {
      stroke: "#4384F5",
      strokeWidth: "1",
      x: "0.5",
      y: "0.5",
      width: "15",
      height: "15",
      rx: "4",
      style: {
        fill: 'none'
      }
    })), React__default.createElement("polygon", {
      fill: "#4384F5",
      points: "4 8.17070347 6.8554326 11.0329509 12.4300003 5.44475349 10.9852468 4 6.84861773 8.13662909 5.44475349 6.72594998"
    })))));
  });

  var CheckboxOnIcon = function CheckboxOnIcon(props) {
    return React.createElement(Icon, props, React.createElement(CheckboxOn, null));
  };

  var Close = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      height: "14px",
      viewBox: "0 0 14 14",
      width: "14px"
    }, props), React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd",
      stroke: "none",
      strokeWidth: "1"
    }, React__default.createElement("polygon", {
      fill: "#000000",
      points: "14 1.41 12.59 8.8817842e-16 7 5.59 1.41 8.8817842e-16 0 1.41 5.59 7 0 12.59 1.41 14 7 8.41 12.59 14 14 12.59 8.41 7"
    })));
  });

  var CloseIcon = function CloseIcon(props) {
    return React.createElement(Icon, props, React.createElement(Close, null));
  };

  var Email = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "18px",
      height: "14px",
      viewBox: "0 0 18 14"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-853.000000, -227.000000)"
    }, React__default.createElement("g", {
      transform: "translate(830.000000, 207.000000)"
    }, React__default.createElement("g", null, React__default.createElement("g", {
      transform: "translate(22.000000, 17.000000)"
    }, React__default.createElement("path", {
      d: "M16.6666667,3.33333333 L3.33333333,3.33333333 C2.41666667,3.33333333 1.675,4.08333333 1.675,5 L1.66666667,15 C1.66666667,15.9166667 2.41666667,16.6666667 3.33333333,16.6666667 L16.6666667,16.6666667 C17.5833333,16.6666667 18.3333333,15.9166667 18.3333333,15 L18.3333333,5 C18.3333333,4.08333333 17.5833333,3.33333333 16.6666667,3.33333333 Z M16.6666667,15 L3.33333333,15 L3.33333333,6.66666667 L10,10.8333333 L16.6666667,6.66666667 L16.6666667,15 Z M10,9.16666667 L3.33333333,5 L16.6666667,5 L10,9.16666667 Z",
      fillOpacity: "0.6",
      fill: "#424D57",
      fillRule: "nonzero"
    })))))));
  });

  var EmailIcon = function EmailIcon(props) {
    return React.createElement(Icon, props, React.createElement(Email, null));
  };

  var EmailFilled = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "21px",
      height: "16px",
      viewBox: "0 0 20 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("path", {
      d: "M18,0 L2,0 C0.9,0 0.01,0.9 0.01,2 L0,14 C0,15.1 0.9,16 2,16 L18,16 C19.1,16 20,15.1 20,14 L20,2 C20,0.9 19.1,0 18,0 Z M17.6,4.25 L10.53,8.67 C10.21,8.87 9.79,8.87 9.47,8.67 L2.4,4.25 C2.15,4.09 2,3.82 2,3.53 C2,2.86 2.73,2.46 3.3,2.81 L10,7 L16.7,2.81 C17.27,2.46 18,2.86 18,3.53 C18,3.82 17.85,4.09 17.6,4.25 Z",
      fill: "#000000",
      fillRule: "nonzero"
    })));
  });

  var EmailFilledIcon = function EmailFilledIcon(props) {
    return React.createElement(Icon, props, React.createElement(EmailFilled, null));
  };

  var Emoji = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      height: "20px",
      viewBox: "0 0 20 20",
      width: "20px"
    }, props), React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd",
      stroke: "none",
      strokeWidth: "1"
    }, React__default.createElement("g", {
      fill: "#000000"
    }, React__default.createElement("path", {
      d: "M13.5,9 C14.3,9 15,8.3 15,7.5 C15,6.7 14.3,6 13.5,6 C12.7,6 12,6.7 12,7.5 C12,8.3 12.7,9 13.5,9 L13.5,9 Z M6.5,9 C7.3,9 8,8.3 8,7.5 C8,6.7 7.3,6 6.5,6 C5.7,6 5,6.7 5,7.5 C5,8.3 5.7,9 6.5,9 L6.5,9 Z M10,16 C12.6,16 14.8,14.3 15.7,12 L4.3,12 C5.2,14.3 7.4,16 10,16 L10,16 Z M10,0 C4.5,0 0,4.5 0,10 C0,15.5 4.5,20 10,20 C15.5,20 20,15.5 20,10 C20,4.5 15.5,0 10,0 L10,0 Z M10,18 C5.6,18 2,14.4 2,10 C2,5.6 5.6,2 10,2 C14.4,2 18,5.6 18,10 C18,14.4 14.4,18 10,18 L10,18 Z"
    }))));
  });

  var EmojiIcon = function EmojiIcon(props) {
    return React.createElement(Icon, props, React.createElement(Emoji, null));
  };

  var Exit = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "24px",
      height: "24px",
      viewBox: "0 0 24 24"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-963.000000, -248.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(960.000000, 245.000000)"
    }, React__default.createElement("path", {
      d: "M12.6125,19.4875 L14.375,21.25 L20.625,15 L14.375,8.75 L12.6125,10.5125 L15.8375,13.75 L3.75,13.75 L3.75,16.25 L15.8375,16.25 L12.6125,19.4875 Z M23.75,3.75 L6.25,3.75 C4.8625,3.75 3.75,4.875 3.75,6.25 L3.75,11.25 L6.25,11.25 L6.25,6.25 L23.75,6.25 L23.75,23.75 L6.25,23.75 L6.25,18.75 L3.75,18.75 L3.75,23.75 C3.75,25.125 4.8625,26.25 6.25,26.25 L23.75,26.25 C25.125,26.25 26.25,25.125 26.25,23.75 L26.25,6.25 C26.25,4.875 25.125,3.75 23.75,3.75 Z"
    })))));
  });

  var ExitIcon = function ExitIcon(props) {
    return React.createElement(Icon, props, React.createElement(Exit, null));
  };

  var Hourglass = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "26px",
      viewBox: "0 0 16 26"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-967.000000, -284.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(960.000000, 282.000000)"
    }, React__default.createElement("path", {
      d: "M7.5,2.5 L7.5,10 L7.5125,10 L7.5,10.0125 L12.5,15 L7.5,20 L7.5125,20.0125 L7.5,20.0125 L7.5,27.5 L22.5,27.5 L22.5,20.0125 L22.4875,20.0125 L22.5,20 L17.5,15 L22.5,10.0125 L22.4875,10 L22.5,10 L22.5,2.5 L7.5,2.5 Z M20,20.625 L20,25 L10,25 L10,20.625 L15,15.625 L20,20.625 Z M15,14.375 L10,9.375 L10,5 L20,5 L20,9.375 L15,14.375 Z"
    })))));
  });

  var HourglassIcon = function HourglassIcon(props) {
    return React.createElement(Icon, props, React.createElement(Hourglass, null));
  };

  var Maximize = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      fill: "none",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24"
    }, props), React__default.createElement("path", {
      d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
    }));
  });

  var MaximizeIcon = function MaximizeIcon(props) {
    return React.createElement(Icon, props, React.createElement(Maximize, null));
  };

  var MenuVertical = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      height: "4px",
      viewBox: "0 0 16 4",
      width: "16px"
    }, props), React__default.createElement("g", {
      fill: "none",
      fillRule: "evenodd",
      stroke: "none",
      strokeWidth: "1"
    }, React__default.createElement("g", {
      fill: "#000000"
    }, React__default.createElement("path", {
      d: "M2,0 C0.9,0 0,0.9 0,2 C0,3.1 0.9,4 2,4 C3.1,4 4,3.1 4,2 C4,0.9 3.1,0 2,0 Z M14,0 C12.9,0 12,0.9 12,2 C12,3.1 12.9,4 14,4 C15.1,4 16,3.1 16,2 C16,0.9 15.1,0 14,0 Z M8,0 C6.9,0 6,0.9 6,2 C6,3.1 6.9,4 8,4 C9.1,4 10,3.1 10,2 C10,0.9 9.1,0 8,0 Z"
    }))));
  });

  var MenuVerticalIcon = function MenuVerticalIcon(props) {
    return React.createElement(Icon, props, React.createElement(MenuVertical, null));
  };

  var Minimize = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      fill: "none",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24"
    }, props), React__default.createElement("path", {
      d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
    }));
  });

  var MinimizeIcon = function MinimizeIcon(props) {
    return React.createElement(Icon, props, React.createElement(Minimize, null));
  };

  var Mute = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-854.000000, -325.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(830.000000, 207.000000)"
    }, React__default.createElement("g", null, React__default.createElement("g", {
      transform: "translate(22.000000, 116.000000)"
    }, React__default.createElement("path", {
      d: "M13.75,10 C13.75,8.525 12.9,7.25833333 11.6666667,6.64166667 L11.6666667,8.48333333 L13.7083333,10.525 C13.7333333,10.3583333 13.75,10.1833333 13.75,10 Z M15.8333333,10 C15.8333333,10.7833333 15.6666667,11.5166667 15.3833333,12.2 L16.6416667,13.4583333 C17.1916667,12.425 17.5,11.25 17.5,10 C17.5,6.43333333 15.0083333,3.45 11.6666667,2.69166667 L11.6666667,4.40833333 C14.075,5.125 15.8333333,7.35833333 15.8333333,10 Z M3.55833333,2.5 L2.5,3.55833333 L6.44166667,7.5 L2.5,7.5 L2.5,12.5 L5.83333333,12.5 L10,16.6666667 L10,11.0583333 L13.5416667,14.6 C12.9833333,15.0333333 12.3583333,15.375 11.6666667,15.5833333 L11.6666667,17.3 C12.8166667,17.0416667 13.8583333,16.5083333 14.7416667,15.7916667 L16.4416667,17.5 L17.5,16.4416667 L10,8.94166667 L3.55833333,2.5 Z M10,3.33333333 L8.25833333,5.075 L10,6.81666667 L10,3.33333333 Z"
    })))))));
  });

  var MuteIcon = function MuteIcon(props) {
    return React.createElement(Icon, props, React.createElement(Mute, null));
  };

  var Unmute = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-854.000000, -325.000000)",
      fill: "#FFFFFF",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(830.000000, 207.000000)"
    }, React__default.createElement("path", {
      d: "M24.5,123.5 L24.5,128.5 L27.8333333,128.5 L32,132.666667 L32,119.333333 L27.8333333,123.5 L24.5,123.5 Z M35.75,126 C35.75,124.525 34.9,123.258333 33.6666667,122.641667 L33.6666667,129.35 C34.9,128.741667 35.75,127.475 35.75,126 Z M33.6666667,118.691667 L33.6666667,120.408333 C36.075,121.125 37.8333333,123.358333 37.8333333,126 C37.8333333,128.641667 36.075,130.875 33.6666667,131.591667 L33.6666667,133.308333 C37.0083333,132.55 39.5,129.566667 39.5,126 C39.5,122.433333 37.0083333,119.45 33.6666667,118.691667 Z"
    })))));
  });

  var UnmuteIcon = function UnmuteIcon(props) {
    return React.createElement(Icon, props, React.createElement(Unmute, null));
  };

  var RadioOff = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-861.000000, -656.000000)"
    }, React__default.createElement("g", {
      transform: "translate(861.000000, 656.000000)"
    }, React__default.createElement("g", null, React__default.createElement("circle", {
      stroke: "#BCC6D0",
      strokeWidth: "1",
      cx: "8",
      cy: "8",
      r: "7.5",
      style: {
        fill: 'none'
      }
    }))))));
  });

  var RadioOffIcon = function RadioOffIcon(props) {
    return React.createElement(Icon, props, React.createElement(RadioOff, null));
  };

  var RadioOn = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "16px",
      height: "16px",
      viewBox: "0 0 16 16",
      version: "1.1"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-861.000000, -626.000000)"
    }, React__default.createElement("g", {
      transform: "translate(861.000000, 626.000000)"
    }, React__default.createElement("g", null, React__default.createElement("circle", {
      stroke: "#4384F5",
      strokeWidth: "1",
      cx: "8",
      cy: "8",
      r: "7.5",
      style: {
        fill: 'none'
      }
    })), React__default.createElement("circle", {
      fill: "#4384F5",
      cx: "8",
      cy: "8",
      r: "3"
    })))));
  });

  var RadioOnIcon = function RadioOnIcon(props) {
    return React.createElement(Icon, props, React.createElement(RadioOn, null));
  };

  var RateBad = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "14px",
      height: "19px",
      viewBox: "0 0 14 19"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-1092.000000, -247.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(832.000000, 237.000000)"
    }, React__default.createElement("path", {
      d: "M262.011431,10.0079649 C264.301872,10.0254688 266.149331,11.871012 266.149331,14.141574 L266.149331,15.006151 C266.149331,15.7362453 266.746389,16.3281036 267.482897,16.3281036 L270.483677,16.3281036 C270.679987,16.3281036 270.875953,16.3444026 271.069519,16.3768295 C272.984075,16.6975635 274.27384,18.4961084 273.950288,20.3939919 L273.161331,25.0218442 C272.786728,27.2191809 270.866945,28.8276198 268.618875,28.8276198 L265.455497,28.8276198 C262.442509,28.8276198 260,26.406381 260,23.4196316 L260,12.0040832 C260,10.9016253 260.893719,10.0079066 261.996177,10.0079066 C262.001262,10.0079066 262.006347,10.007926 262.011431,10.0079649 Z M268.206897,24.4827922 L272.086361,24.4827922 L272.086361,25.4442124 L269.168317,25.4442124 C268.637339,25.4442124 268.206897,25.0137699 268.206897,24.4827922 Z M268.206897,22.0689991 L273.056228,22.0689991 L273.056228,23.0304193 L269.168317,23.0304193 C268.637339,23.0304193 268.206897,22.5999768 268.206897,22.0689991 Z M268.206897,19.655206 L273.541161,19.655206 L273.541161,20.6166262 L269.168317,20.6166262 C268.637339,20.6166262 268.206897,20.1861837 268.206897,19.655206 Z M261.939732,23.4196316 C261.939732,25.3444256 263.513794,26.9047795 265.455497,26.9047795 L268.618875,26.9047795 C269.920389,26.9047795 271.031842,25.9735781 271.248717,24.7014358 L272.037675,20.0735835 C272.182715,19.2228081 271.604545,18.4165638 270.746296,18.2727865 C270.659525,18.2582503 270.571678,18.2509439 270.483677,18.2509439 L267.482897,18.2509439 C265.675104,18.2509439 264.209598,16.7982006 264.209598,15.006151 L264.209598,14.141574 C264.209598,12.9271831 263.221501,11.9401098 261.996478,11.930748 L261.939732,11.9303143 L261.939732,23.4196316 Z",
      transform: "translate(267.000000, 19.413810) scale(-1, -1) translate(-267.000000, -19.413810) "
    })))));
  });

  var RateBadIcon = function RateBadIcon(props) {
    return React.createElement(Icon, props, React.createElement(RateBad, null));
  };

  var RateGood = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "14px",
      height: "19px",
      viewBox: "0 0 14 19"
    }, props), React__default.createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd"
    }, React__default.createElement("g", {
      transform: "translate(-1047.000000, -247.000000)",
      fill: "#424D57",
      fillRule: "nonzero"
    }, React__default.createElement("g", {
      transform: "translate(832.000000, 237.000000)"
    }, React__default.createElement("path", {
      d: "M217.011431,10.0079649 C219.301872,10.0254688 221.149331,11.871012 221.149331,14.141574 L221.149331,15.006151 C221.149331,15.7362453 221.746389,16.3281036 222.482897,16.3281036 L225.483677,16.3281036 C225.679987,16.3281036 225.875953,16.3444026 226.069519,16.3768295 C227.984075,16.6975635 229.27384,18.4961084 228.950288,20.3939919 L228.161331,25.0218442 C227.786728,27.2191809 225.866945,28.8276198 223.618875,28.8276198 L220.455497,28.8276198 C217.442509,28.8276198 215,26.406381 215,23.4196316 L215,12.0040832 C215,10.9016253 215.893719,10.0079066 216.996177,10.0079066 C217.001262,10.0079066 217.006347,10.007926 217.011431,10.0079649 Z M223.206897,24.4827922 L227.086361,24.4827922 L227.086361,25.4442124 L224.168317,25.4442124 C223.637339,25.4442124 223.206897,25.0137699 223.206897,24.4827922 Z M223.206897,22.0689991 L228.056228,22.0689991 L228.056228,23.0304193 L224.168317,23.0304193 C223.637339,23.0304193 223.206897,22.5999768 223.206897,22.0689991 Z M223.206897,19.655206 L228.541161,19.655206 L228.541161,20.6166262 L224.168317,20.6166262 C223.637339,20.6166262 223.206897,20.1861837 223.206897,19.655206 Z M216.939732,23.4196316 C216.939732,25.3444256 218.513794,26.9047795 220.455497,26.9047795 L223.618875,26.9047795 C224.920389,26.9047795 226.031842,25.9735781 226.248717,24.7014358 L227.037675,20.0735835 C227.182715,19.2228081 226.604545,18.4165638 225.746296,18.2727865 C225.659525,18.2582503 225.571678,18.2509439 225.483677,18.2509439 L222.482897,18.2509439 C220.675104,18.2509439 219.209598,16.7982006 219.209598,15.006151 L219.209598,14.141574 C219.209598,12.9271831 218.221501,11.9401098 216.996478,11.930748 L216.939732,11.9303143 L216.939732,23.4196316 Z"
    })))));
  });

  var RateGoodIcon = function RateGoodIcon(props) {
    return React.createElement(Icon, props, React.createElement(RateGood, null));
  };

  var Search = (function (_ref) {
    var _ref$styles = _ref.styles,
        props = _objectWithoutPropertiesLoose(_ref, ["styles"]);

    return React__default.createElement("svg", _extends({
      width: "28px",
      height: "28px",
      viewBox: "0 0 512 512"
    }, props), React__default.createElement("path", {
      d: "M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z"
    }));
  });

  var SearchIcon = function SearchIcon(props) {
    return React.createElement(Icon, props, React.createElement(Search, null));
  };

  var ElementButtons =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(ElementButtons, _React$Component);

    function ElementButtons() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this.handleButtonClick = function (key) {
        return function (event) {
          _this.props.onButtonClick(event, key);
        };
      };

      return _this;
    }

    var _proto = ElementButtons.prototype;

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          buttons = _this$props.buttons,
          onButtonClick = _this$props.onButtonClick;
      return React.createElement(StyledButtons, null, buttons.map(function (_ref, index) {
        var text = _ref.text,
            _key = _ref.key,
            buttonProps = _objectWithoutPropertiesLoose(_ref, ["text", "key"]);

        var key = _key !== undefined ? _key : index;
        return React.createElement(MessageButton, _extends({
          key: key,
          label: text,
          onClick: _this2.handleButtonClick(key)
        }, buttonProps));
      }));
    };

    return ElementButtons;
  }(React.Component);

  ElementButtons.defaultProps = {
    onButtonClick: noop
  };

  var stopPropagation = function stopPropagation(event) {
    return event.stopPropagation();
  }; // eslint-disable-next-line jsx-a11y/anchor-has-content


  var Link = function Link(props) {
    return React.createElement("a", _extends({}, props, {
      onClick: stopPropagation,
      rel: "nofollow noopener",
      target: "_blank"
    }));
  };

  var StyledImg =
  /*#__PURE__*/
  styled$1('img', {
    target: "e9ztsyy0"
  })("display:block;width:100%;height:150px;object-fit:cover;");
  var StyledImageContainer =
  /*#__PURE__*/
  styled$1('div', {
    target: "e9ztsyy1"
  })("width:100%;margin:0 auto;");

  var getThumbnailProps = function getThumbnailProps(url, srcset) {
    var props = {
      src: url
    };

    if (srcset !== undefined) {
      props.srcSet = srcset;
    }

    return props;
  }; // eslint-disable-next-line react/no-multi-comp


  var Image = function Image(_ref) {
    var url = _ref.url,
        srcset = _ref.srcset,
        props = _objectWithoutPropertiesLoose(_ref, ["url", "srcset"]);

    return React.createElement(StyledMedia, props, React.createElement(StyledImageContainer, null, React.createElement(StyledImg, _extends({
      alt: ""
    }, getThumbnailProps(url, srcset)))));
  }; // eslint-disable-next-line react/no-multi-comp


  var CardImage = function CardImage(_ref2) {
    var link = _ref2.link,
        props = _objectWithoutPropertiesLoose(_ref2, ["link"]);

    return link ? React.createElement(Link, {
      href: link,
      style: props.style
    }, Image(props)) : Image(props);
  };

  CardImage.propTypes = {
    link: PropTypes.string,
    url: PropTypes.string.isRequired,
    srcSet: PropTypes.string
  };

  var minWidth =
  /*#__PURE__*/
  css("width:230px;");

  var Card =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$1(Card, _React$Component);

    function Card() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Card.prototype;

    _proto.render = function render() {
      var _this$props = this.props,
          card = _this$props.card,
          onButtonClick = _this$props.onButtonClick,
          restProps = _objectWithoutPropertiesLoose(_this$props, ["card", "onButtonClick"]);

      return React.createElement(StyledBubble, _extends({
        className: minWidth
      }, restProps), card.image && React.createElement(CardImage, card.image), (card.title || card.subtitle) && React.createElement(MessageTitle, {
        subtitle: card.subtitle,
        title: card.title
      }), card.buttons && React.createElement(ElementButtons, {
        buttons: card.buttons,
        onButtonClick: onButtonClick
      }));
    };

    return Card;
  }(React.Component);

  var reversed = function (easing) {
      return function (p) {
          return 1 - easing(1 - p);
      };
  };
  var createExpoIn = function (power) {
      return function (p) {
          return Math.pow(p, power);
      };
  };
  var easeIn = /*#__PURE__*/createExpoIn(2);
  var easeOut = /*#__PURE__*/reversed(easeIn);

  /**
   * callbag-concat
   * --------------
   *
   * Callbag factory that concatenates the data from multiple (2 or more)
   * callbag sources. It starts each source at a time: waits for the previous
   * source to end before starting the next source. Works with both pullable
   * and listenable sources.
   *
   * `npm install callbag-concat`
   *
   * Example:
   *
   *     const fromIter = require('callbag-from-iter');
   *     const iterate = require('callbag-iterate');
   *     const concat = require('callbag-concat');
   *
   *     const source = concat(fromIter([10,20,30]), fromIter(['a','b']));
   *
   *     iterate(x => console.log(x))(source); // 10
   *                                           // 20
   *                                           // 30
   *                                           // a
   *                                           // b
   */
  var UNIQUE = {};

  var concat = function concat() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    return function (start, sink) {
      if (start !== 0) return;
      var n = sources.length;

      if (n === 0) {
        sink(0, function () {});
        sink(2);
        return;
      }

      var i = 0;
      var sourceTalkback;
      var lastPull = UNIQUE;

      var talkback = function talkback(t, d) {
        if (t === 1) lastPull = d;
        sourceTalkback(t, d);
      };

      (function next() {
        if (i === n) {
          sink(2);
          return;
        }

        sources[i](0, function (t, d) {
          if (t === 0) {
            sourceTalkback = d;
            if (i === 0) sink(0, talkback);else if (lastPull !== UNIQUE) sourceTalkback(1, lastPull);
          } else if (t === 2 && d) {
            sink(2, d);
          } else if (t === 2) {
            i++;
            next();
          } else {
            sink(t, d);
          }
        });
      })();
    };
  };

  function of() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return function (start, sink) {
      if (start !== 0) return;
      var disposed = false;
      sink(0, function (type) {
        if (type !== 2) return;
        disposed = true;
        values.length = 0;
      });

      while (values.length !== 0) {
        sink(1, values.shift());
      }

      if (disposed) return;
      sink(2);
    };
  }

  function concatWith() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return function (source) {
      return concat(source, of.apply(void 0, args));
    };
  }

  /**
   * callbag-map
   * -----------
   *
   * Callbag operator that applies a transformation on data passing through it.
   * Works on either pullable or listenable sources.
   *
   * `npm install callbag-map`
   *
   * Example:
   *
   *     const fromIter = require('callbag-from-iter');
   *     const iterate = require('callbag-iterate');
   *     const map = require('callbag-map');
   *
   *     const source = map(x => x * 0.1)(fromIter([10,20,30,40]));
   *
   *     iterate(x => console.log(x))(source); // 1
   *                                           // 2
   *                                           // 3
   *                                           // 4
   */
  var map = function map(f) {
    return function (source) {
      return function (start, sink) {
        if (start !== 0) return;
        source(0, function (t, d) {
          sink(t, t === 1 ? f(d) : d);
        });
      };
    };
  };

  var readme = map;

  var share = function share(source) {
    var sinks = [];
    var sourceTalkback;
    return function shared(start, sink) {
      if (start !== 0) return;
      sinks.push(sink);

      var talkback = function talkback(t, d) {
        if (t === 2) {
          var i = sinks.indexOf(sink);
          if (i > -1) sinks.splice(i, 1);
          if (!sinks.length) sourceTalkback(2);
        } else {
          sourceTalkback(t, d);
        }
      };

      if (sinks.length === 1) {
        source(0, function (t, d) {
          if (t === 0) {
            sourceTalkback = d;
            sink(0, talkback);
          } else {
            for (var _iterator = sinks.slice(0), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
              var _ref;

              if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
              }

              var s = _ref;
              s(t, d);
            }
          }

          if (t === 2) sinks = [];
        });
        return;
      }

      sink(0, talkback);
    };
  };

  var index$2 =
  /*#__PURE__*/
  share(function (start, sink) {
    if (start !== 0) return;
    var id;

    function nextCb(ms) {
      next();
      sink(1, ms);
    }

    function next() {
      id = requestAnimationFrame(nextCb);
    }

    next();
    sink(0, function (t) {
      if (t === 2) cancelAnimationFrame(id);
    });
  });

  var flatten = function flatten(source) {
    return function (start, sink) {
      if (start !== 0) return;
      var outerEnded = false;
      var outerTalkback;
      var innerTalkback;

      function talkback(t, d) {
        if (t === 1) (innerTalkback || outerTalkback)(1, d);

        if (t === 2) {
          innerTalkback && innerTalkback(2);
          outerTalkback(2);
        }
      }

      source(0, function (T, D) {
        if (T === 0) {
          outerTalkback = D;
          sink(0, talkback);
        } else if (T === 1) {
          var innerSource = D;
          innerTalkback && innerTalkback(2);
          innerSource(0, function (t, d) {
            if (t === 0) {
              innerTalkback = d;
              innerTalkback(1);
            } else if (t === 1) sink(1, d);else if (t === 2 && d) {
              outerTalkback(2);
              sink(2, d);
            } else if (t === 2) {
              if (outerEnded) sink(2);else {
                innerTalkback = void 0;
                outerTalkback(1);
              }
            }
          });
        } else if (T === 2 && D) {
          innerTalkback && innerTalkback(2);
          sink(2, D);
        } else if (T === 2) {
          if (!innerTalkback) sink(2);else outerEnded = true;
        }
      });
    };
  };

  var lazy = function lazy(f) {
    return function (start, sink) {
      if (start === 0) {
        var unsubed = false;
        sink(0, function (type) {
          if (type === 2) unsubed = true;
        });
        sink(1, f());
        if (!unsubed) sink(2);
      }
    };
  };

  var defer = function defer(factory) {
    return flatten(lazy(factory));
  };

  var index$3 =
  /*#__PURE__*/
  defer(function () {
    var start = Date.now();
    return readme(function () {
      return Date.now() - start;
    })(index$2);
  });

  function takeWhile(predicate) {
    return function (source) {
      return function (start, sink) {
        if (start !== 0) return;
        var sourceTalkback;
        source(0, function (type, data) {
          if (type === 0) {
            sourceTalkback = data;
          }

          if (type === 1 && !predicate(data)) {
            sourceTalkback(2);
            sink(2);
            return;
          }

          sink(type, data);
        });
      };
    };
  }

  function durationProgress(ms) {
    return concatWith(1)(takeWhile(function (progress) {
      return progress <= 1;
    })(readme(function (elapsed) {
      return elapsed / ms;
    })(index$3)));
  }

  /**
   * callbag-for-each
   * ----------------
   *
   * Callbag sink that consume both pullable and listenable sources. When called
   * on a pullable source, it will iterate through its data. When called on a
   * listenable source, it will observe its data.
   *
   * `npm install callbag-for-each`
   *
   * Examples
   * --------
   *
   * Consume a pullable source:
   *
   *     const fromIter = require('callbag-from-iter');
   *     const forEach = require('callbag-for-each');
   *
   *     const source = fromIter([10,20,30,40])
   *
   *     forEach(x => console.log(x))(source); // 10
   *                                           // 20
   *                                           // 30
   *                                           // 40
   *
   * Consume a listenable source:
   *
   *     const interval = require('callbag-interval');
   *     const forEach = require('callbag-for-each');
   *
   *     const source = interval(1000);
   *
   *     forEach(x => console.log(x))(source); // 0
   *                                           // 1
   *                                           // 2
   *                                           // 3
   *                                           // ...
   */
  var forEach = function forEach(operation) {
    return function (source) {
      var talkback;
      source(0, function (t, d) {
        if (t === 0) talkback = d;
        if (t === 1) operation(d);
        if (t === 1 || t === 0) talkback(1);
      });
    };
  };

  var readme$1 = forEach;

  /**
   * callbag-pipe
   * ------------
   *
   * Utility function for plugging callbags together in chain. This utility
   * actually doesn't rely on Callbag specifics, and is really similar to
   * Ramda's `pipe` or lodash's `flow`.
   * 
   * Implementation of `callbag-pipe` using `R.pipe` could look like this:
   *
   * const pipe = (source, ...cbs) => R.pipe(...cbs)(source)
   * 
   * This exists to play nicely with the ecosystem,
   * and to facilitate the import of the function.
   *
   * `npm install callbag-pipe`
   *
   * Example:
   *
   * Create a source with `pipe`, then pass it to a `forEach`:
   *
   *     const interval = require('callbag-interval');
   *     const forEach = require('callbag-for-each');
   *     const combine = require('callbag-combine');
   *     const pipe = require('callbag-pipe');
   *     const take = require('callbag-take');
   *     const map = require('callbag-map');
   *
   *     const source = pipe(
   *       combine(interval(100), interval(350)),
   *       map(([x, y]) => `X${x},Y${y}`),
   *       take(10)
   *     );
   *
   *     forEach(x => console.log(x))(source); // X2,Y0
   *                                           // X3,Y0
   *                                           // X4,Y0
   *                                           // X5,Y0
   *                                           // X6,Y0
   *                                           // X6,Y1
   *                                           // X7,Y1
   *                                           // X8,Y1
   *                                           // X9,Y1
   *                                           // X9,Y2
   *
   *
   * Or use `pipe` to go all the way from source to sink:
   *
   *     const interval = require('callbag-interval');
   *     const forEach = require('callbag-for-each');
   *     const combine = require('callbag-combine');
   *     const pipe = require('callbag-pipe');
   *     const take = require('callbag-take');
   *     const map = require('callbag-map');
   *
   *     pipe(
   *       combine(interval(100), interval(350)),
   *       map(([x, y]) => `X${x},Y${y}`),
   *       take(10),
   *       forEach(x => console.log(x))
   *     );
   *     // X2,Y0
   *     // X3,Y0
   *     // X4,Y0
   *     // X5,Y0
   *     // X6,Y0
   *     // X6,Y1
   *     // X7,Y1
   *     // X8,Y1
   *     // X9,Y1
   *     // X9,Y2
   *
   *
   * Nesting
   * -------
   *
   * To use pipe inside another pipe, you need to give the inner pipe an
   * argument, e.g. `s => pipe(s, ...`:
   *
   *     const interval = require('callbag-interval');
   *     const forEach = require('callbag-for-each');
   *     const combine = require('callbag-combine');
   *     const pipe = require('callbag-pipe');
   *     const take = require('callbag-take');
   *     const map = require('callbag-map');
   *
   *     pipe(
   *       combine(interval(100), interval(350)),
   *       s => pipe(s,
   *         map(([x, y]) => `X${x},Y${y}`),
   *         take(10)
   *       ),
   *       forEach(x => console.log(x))
   *     );
   *
   *
   * This means you can use pipe to create a new operator:
   *
   *     const mapThenTake = (f, amount) =>
   *       s => pipe(s, map(f), take(amount));
   *
   *     pipe(
   *       combine(interval(100), interval(350)),
   *       mapThenTake(([x, y]) => `X${x},Y${y}`, 10),
   *       forEach(x => console.log(x))
   *     );
   *
   */
  function pipe() {
    for (var _len = arguments.length, cbs = new Array(_len), _key = 0; _key < _len; _key++) {
      cbs[_key] = arguments[_key];
    }

    var res = cbs[0];

    for (var i = 1, n = cbs.length; i < n; i++) {
      res = cbs[i](res);
    }

    return res;
  }

  var readme$2 = pipe;

  var StyledCarouselContainer =
  /*#__PURE__*/
  styled$1('div', {
    target: "epptpc30"
  })("position:relative;width:100%;display:flex;");
  var StyledCardsContainer =
  /*#__PURE__*/
  styled$1('div', {
    target: "epptpc31"
  })("display:flex;width:100%;overflow-x:", function (props) {
    return props.mobile ? 'auto' : 'hidden';
  }, ";-webkit-overflow-scrolling:touch;align-items:flex-start;-ms-overflow-style:none;&::-webkit-scrollbar{display:none;}");
  var StyledCardContainer =
  /*#__PURE__*/
  styled$1('div', {
    target: "epptpc32"
  })("flex-grow:0;flex-shrink:0;& + &{margin-left:0.5em;}");
  var ArrowButton =
  /*#__PURE__*/
  styled$1('button', {
    target: "epptpc33"
  })("position:absolute;width:30px;height:30px;border-radius:50%;background:#fff;border:0;box-shadow:0 4px 12px rgba(0,0,0,0.3);outline:none;text-align:center;top:32%;display:flex;align-items:center;justify-content:center;padding:0;&:hover{cursor:pointer;}svg{display:inline;}", function (_ref) {
    var _ref2;

    var variant = _ref.variant;
    return _ref2 = {}, _ref2[variant] = '.5em', _ref2;
  }, ";");

  var distance = function distance(max) {
    return function (percent) {
      return percent * max;
    };
  };

  var animateScrollX = function animateScrollX(targetX, durationMs, element) {
    var initialX = element.scrollLeft;
    var diffX = targetX - initialX;
    readme$2(durationProgress(durationMs), readme(easeOut), readme(distance(diffX)), readme$1(function (x) {
      element.scrollLeft = initialX + x;
    }));
  };

  var calculateItemsWidth = function calculateItemsWidth(_ref3) {
    var count = _ref3.count,
        width = _ref3.width,
        spacing = _ref3.spacing;
    return count * width + (count - 1) * spacing;
  };

  var Carousel =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inheritsLoose$1(Carousel, _React$PureComponent);

    function Carousel() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
      _this.state = {
        showScrollLeft: false,
        showScrollRight: false
      };

      _this.getCardContainerRef = function (ref) {
        _this.cardContainerRef = ref;
      };

      _this.showAppropriateArrowsIfNeeded = function () {
        var _assertThisInitialize = _assertThisInitialized(_this),
            cardContainerRef = _assertThisInitialize.cardContainerRef;

        _this.setState({
          showScrollLeft: !isScrolledToLeft(cardContainerRef),
          showScrollRight: !isScrolledToRight(cardContainerRef)
        });
      };

      _this.handleContainerScroll = throttle(200, _this.showAppropriateArrowsIfNeeded);
      _this.scrollToDirection = memoize$1(function (direction) {
        return function (event) {
          event.stopPropagation();
          var _this$cardContainerRe = _this.cardContainerRef,
              currentX = _this$cardContainerRe.scrollLeft,
              visibleWidth = _this$cardContainerRe.offsetWidth,
              scrollWidth = _this$cardContainerRe.scrollWidth;
          var calculatedX = currentX + direction * visibleWidth;
          var clampedX = direction === 1 ? Math.min(calculatedX, scrollWidth - visibleWidth) : Math.max(calculatedX, 0);
          var targetX = calculatedX === clampedX ? _this.findXToCenterNextBatch(calculatedX, direction) : clampedX;
          animateScrollX(targetX, 300, _this.cardContainerRef);
        };
      });
      return _this;
    }

    var _proto = Carousel.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.showAppropriateArrowsIfNeeded();
      this._observer = new index$1(debounce(200, this.showAppropriateArrowsIfNeeded));

      this._observer.observe(this.cardContainerRef);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._observer.disconnect();
    };

    _proto.findXToCenterNextBatch = function findXToCenterNextBatch(targetX, direction) {
      var _this$cardContainerRe2 = this.cardContainerRef,
          childNodes = _this$cardContainerRe2.childNodes,
          visibleWidth = _this$cardContainerRe2.offsetWidth;
      var first = childNodes[0],
          second = childNodes[1];

      var _first$getBoundingCli = first.getBoundingClientRect(),
          right = _first$getBoundingCli.right,
          width = _first$getBoundingCli.width;

      var spacing = second.getBoundingClientRect().left - right;
      var itemsCount = Math.abs(targetX) / (width + spacing);
      var completeItemsCount = direction === 1 ? Math.floor(itemsCount) : Math.ceil(itemsCount);
      var obscuredX = completeItemsCount * (width + spacing);
      var estimatedVisibleCount = Math.floor(visibleWidth / (width + spacing));
      var estimateItemsWidth = calculateItemsWidth({
        count: estimatedVisibleCount,
        width: width,
        spacing: spacing
      });
      var visibleCount = estimateItemsWidth + width <= visibleWidth ? estimatedVisibleCount + 1 : estimatedVisibleCount;
      var itemsWidth = calculateItemsWidth({
        count: visibleCount,
        width: width,
        spacing: spacing
      });
      var finalX = obscuredX + itemsWidth / 2 - visibleWidth / 2;
      return finalX;
    };

    _proto.render = function render() {
      var _this$props = this.props,
          children = _this$props.children,
          mobile = _this$props.mobile;
      return React.createElement(StyledCarouselContainer, null, React.createElement(StyledCardsContainer, {
        innerRef: this.getCardContainerRef,
        mobile: mobile,
        onScroll: this.handleContainerScroll
      }, React.Children.map(children, function (child) {
        return React.createElement(StyledCardContainer, null, child);
      })), this.state.showScrollLeft && React.createElement(ArrowButton, {
        onClick: this.scrollToDirection(-1),
        variant: "left"
      }, React.createElement(ArrowLeftIcon, null)), this.state.showScrollRight && React.createElement(ArrowButton, {
        onClick: this.scrollToDirection(1),
        variant: "right"
      }, React.createElement(ArrowRightIcon, null)));
    };

    return Carousel;
  }(React.PureComponent);

  Carousel.defaultProps = {
    mobile: typeof window !== 'undefined' ? /mobile/gi.test(navigator.userAgent) : false
  };

  exports.AddIcon = AddIcon;
  exports.AgentBar = AgentBar;
  exports.ArrowLeftIcon = ArrowLeftIcon;
  exports.ArrowRightIcon = ArrowRightIcon;
  exports.AttachIcon = AttachIcon;
  exports.Avatar = Avatar;
  exports.Bubble = StyledBubble;
  exports.Card = Card;
  exports.Carousel = Carousel;
  exports.ChatIcon = ChatIcon;
  exports.ChatList = ChatList;
  exports.ChatListItem = ChatListItem;
  exports.CheckboxOffIcon = CheckboxOffIcon;
  exports.CheckboxOnIcon = CheckboxOnIcon;
  exports.CloseIcon = CloseIcon;
  exports.Column = StyledColumn;
  exports.ComposerSpy = ComposerSpy;
  exports.EmailFilledIcon = EmailFilledIcon;
  exports.EmailIcon = EmailIcon;
  exports.EmojiIcon = EmojiIcon;
  exports.ExitIcon = ExitIcon;
  exports.Fill = Fill;
  exports.Fit = Fit;
  exports.FixedWrapper = FixedWrapper;
  exports.HourglassIcon = HourglassIcon;
  exports.Icon = Icon;
  exports.IconButton = StyledButton;
  exports.MaximizeIcon = MaximizeIcon;
  exports.MenuVerticalIcon = MenuVerticalIcon;
  exports.Message = Message;
  exports.MessageButton = MessageButton;
  exports.MessageButtons = StyledButtons;
  exports.MessageGroup = MessageGroup;
  exports.MessageList = MessageList$1;
  exports.MessageListItem = MessageListItem;
  exports.MessageListSpy = MessageListSpy;
  exports.MessageMedia = StyledMedia;
  exports.MessageText = StyledText;
  exports.MessageTitle = MessageTitle;
  exports.MinimizeIcon = MinimizeIcon;
  exports.MuteIcon = MuteIcon;
  exports.QuickReplies = QuickReplies;
  exports.QuickReply = QuickReply;
  exports.RadioOffIcon = RadioOffIcon;
  exports.RadioOnIcon = RadioOnIcon;
  exports.RateBadIcon = RateBadIcon;
  exports.RateGoodIcon = RateGoodIcon;
  exports.Row = StyledRow;
  exports.SearchIcon = SearchIcon;
  exports.SendButton = SendButton$1;
  exports.SendIcon = SendIcon;
  exports.Subtitle = SubTitle;
  exports.TextComposer = TextComposer;
  exports.TextInput = TextInput$1;
  exports.ThemeProvider = TopLevelThemeProvider;
  exports.Title = Title;
  exports.TitleBar = TitleBar;
  exports.UnmuteIcon = UnmuteIcon;
  exports.css = css;
  exports.cx = cx;
  exports.darkTheme = darkTheme;
  exports.defaultTheme = defaultTheme;
  exports.elegantTheme = elegantTheme;
  exports.injectGlobal = injectGlobal;
  exports.keyframes = keyframes;
  exports.purpleTheme = purpleTheme;
  exports.styled = styled$1;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
