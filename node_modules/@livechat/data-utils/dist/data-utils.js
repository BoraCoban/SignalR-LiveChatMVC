'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function add(first, second) {
  return first + second;
}

var _ref = {},
    hasOwnProperty = _ref.hasOwnProperty;
function hasOwn(prop, obj) {
  return hasOwnProperty.call(obj, prop);
}

function assign() {
  // eslint-disable-next-line no-func-assign
  assign = Object.assign || function (target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      for (var key in source) {
        if (hasOwn(key, source)) {
          target[key] = source[key];
        }
      }
    });
    return target;
  };

  return assign.apply(void 0, arguments);
}

function flatMap(iteratee, arr) {
  var _ref;

  return (_ref = []).concat.apply(_ref, arr.map(iteratee));
}

function chain(fn, listOrFn) {
  if (typeof listOrFn === 'function') {
    return function (list) {
      return fn(listOrFn(list))(list);
    };
  }

  return flatMap(fn, listOrFn);
}

var isArray = Array.isArray;

function isObject(obj) {
  return typeof obj === 'object' && obj !== null && !isArray(obj);
}

function mapValues(mapper, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    acc[key] = mapper(obj[key]);
    return acc;
  }, {});
}

function cloneDeep(value) {
  if (isArray(value)) {
    return value.map(cloneDeep);
  }

  if (isObject(value)) {
    return mapValues(cloneDeep, value);
  }

  return value;
}

// slightly simplified version of https://github.com/sindresorhus/camelcase/blob/a526ef0399f9a1310eaacafa0ae4a69da4a2f1ad/index.js
// TODO: possibly could be rewritten using short-ish regexp
var preserveCamelCase = function preserveCamelCase(input) {
  var text = input;
  var isLastCharLower = false;
  var isLastCharUpper = false;
  var isLastLastCharUpper = false;

  for (var index = 0; index < text.length; index++) {
    var char = text[index];

    if (isLastCharLower && /[a-zA-Z]/.test(char) && char.toUpperCase() === char) {
      text = text.slice(0, index) + '-' + text.slice(index);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      index++;
    } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(char) && char.toLowerCase() === char) {
      text = text.slice(0, index - 1) + '-' + text.slice(index - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = char.toLowerCase() === char;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = char.toUpperCase() === char;
    }
  }

  return text;
};

function camelCase(input) {
  var text = input.trim();

  if (text.length === 0) {
    return '';
  }

  if (text.length === 1) {
    return text.toLowerCase();
  }

  if (/^[a-z\d]+$/.test(text)) {
    return text;
  }

  var hasUpperCase = text !== text.toLowerCase();

  if (hasUpperCase) {
    text = preserveCamelCase(text);
  }

  text = text.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, function (match, p1) {
    return p1.toUpperCase();
  });
  return text;
}

function compact(collection) {
  return isArray(collection) ? collection.filter(function (value) {
    return value !== null && value !== undefined;
  }) : Object.keys(collection).reduce(function (result, key) {
    var value = collection[key];

    if (value !== null && value !== undefined) {
      result[key] = value;
    }

    return result;
  }, {});
}

function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return funcs.reduce(function (composed, next) {
    return function () {
      return composed(next.apply(void 0, arguments));
    };
  });
}

function debounce(ms, fn) {
  // actual return type of setTimeout differs per platform (browser vs node)
  var timeoutId;
  return function () {
    clearTimeout(timeoutId);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    timeoutId = setTimeout.apply(void 0, [fn, ms].concat(args));
  };
}

function isNil(value) {
  return value === null || value === undefined;
}

function defaultTo(defaultValue) {
  return function (value) {
    return isNil(value) ? defaultValue : value;
  };
}

function drop(count, arr) {
  return arr.slice(count);
}

function dropRight(count, arr) {
  return arr.slice(0, -count);
}

function ensureArray(maybeArr) {
  return isArray(maybeArr) ? maybeArr : [maybeArr];
}

// eslint-disable-next-line consistent-return
function find(predicate, arr) {
  for (var index = 0; index < arr.length; index++) {
    var element = arr[index];

    if (predicate(element)) {
      return element;
    }
  }
}

function findIndex(predicate, arr) {
  for (var index = 0; index < arr.length; index++) {
    if (predicate(arr[index])) {
      return index;
    }
  }

  return -1;
}

function findKey(predicate, obj) {
  return find(function (key) {
    return predicate(obj[key]);
  }, Object.keys(obj));
}

// eslint-disable-next-line consistent-return
function findLast(predicate, arr) {
  for (var index = arr.length - 1; index >= 0; index--) {
    if (predicate(arr[index])) {
      return arr[index];
    }
  }
}

function findLastIndexFrom(predicate, startIndex, arr) {
  for (var index = startIndex; index >= 0; index--) {
    if (predicate(arr[index])) {
      return index;
    }
  }

  return -1;
}

function findLastIndex(predicate, arr) {
  return findLastIndexFrom(predicate, arr.length - 1, arr);
}

function filledArray(length, value) {
  var arr = [];

  while (length--) {
    arr.push(value);
  }

  return arr;
}

// eslint-disable-next-line lodash-fp/prefer-identity
function identity(value) {
  return value;
}

function flatten(arr) {
  return flatMap(identity, arr);
}

// previous version was written like this, but it seems that TS can't intersect function types like this? it infers (any, any) => any from this
// type IndexerCallback<T extends { [key: string]: any }> = { [P in keyof T]: (val: T[P], key: P) => any }[keyof T]
function forOwn(callback, obj) {
  return Object.keys(obj).forEach(function (key) {
    callback(obj[key], key);
  });
}

function fromPairs(pairs) {
  return pairs.reduce(function (obj, _ref) {
    var key = _ref[0],
        value = _ref[1];
    obj[key] = value;
    return obj;
  }, {});
}

function generateRandomId() {
  return Math.random().toString(36).substring(2);
}

function generateUniqueId(map) {
  var id = generateRandomId();
  return hasOwn(id, map) ? generateUniqueId(map) : id;
}

// based on https://github.com/developit/dlv/blob/d7ec976d12665f1c25dec2acf955dfc2e8757a9c/index.js
function get(propPath, obj) {
  var arrPath = typeof propPath === 'string' ? propPath.split('.') : propPath;
  var pathPartIndex = 0;
  var result = obj;

  while (result && pathPartIndex < arrPath.length) {
    result = result[arrPath[pathPartIndex++]];
  }

  return result;
}

function getOr(defaultValue, prop, obj) {
  var propValue = get(prop, obj);
  return propValue !== undefined && propValue !== null ? propValue : defaultValue;
}

function groupBy(mapper, collection) {
  return Object.keys(collection).reduce(function (grouped, key) {
    var element = collection[key];
    var groupKey = mapper(element);
    grouped[groupKey] = grouped[groupKey] || [];
    grouped[groupKey].push(element);
    return grouped;
  }, {});
}

function groupKeys(mapper, obj) {
  return Object.keys(obj).reduce(function (grouped, key) {
    var groupKey = mapper(key);
    grouped[groupKey] = grouped[groupKey] || {};
    grouped[groupKey][key] = obj[key];
    return grouped;
  }, {});
}

function includes(value, arr) {
  return arr.indexOf(value) !== -1;
}

function isEmpty(collection) {
  return (isArray(collection) ? collection : Object.keys(collection)).length === 0;
}

function isFalsy (value) {
  return !value;
}

function isTruthy (value) {
  return !!value;
}

var isPromise = function isPromise(promise) {
  return isObject(promise) && typeof promise.then === 'function';
};

function keyBy(prop, arr) {
  return arr.reduce(function (acc, el) {
    acc[el[prop]] = el;
    return acc;
  }, {});
}

function last(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : null;
}

function mapKeys(mapper, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    acc[mapper(key)] = obj[key];
    return acc;
  }, {});
}

function mapValuesIndexed(iteratee, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    acc[key] = iteratee(obj[key], key);
    return acc;
  }, {});
}

function merge(objA, objB) {
  if (isEmpty(objB)) {
    return objA;
  }

  var result = {};
  forOwn(function (value, key) {
    if (hasOwn(key, objB)) {
      if (isObject(objA[key]) && isObject(objB[key])) {
        result[key] = merge(objA[key], objB[key]);
      } else {
        result[key] = objB[key];
      }
    } else {
      result[key] = objA[key];
    }
  }, objA);
  forOwn(function (value, key) {
    if (!hasOwn(key, result)) {
      result[key] = objB[key];
    }
  }, objB);
  return result;
}

function mergeAll(objs) {
  if (objs.length === 0) {
    return {};
  }

  var first = objs[0],
      rest = objs.slice(1);
  return rest.reduce(function (merged, obj) {
    return merge(merged, obj);
  }, first);
}

function memoizeWith(keyResolver, func) {
  var cache = {};
  return function () {
    var key = keyResolver.apply(void 0, arguments);

    if (hasOwn(key, cache)) {
      return cache[key];
    }

    var value = func.apply(void 0, arguments);
    cache[key] = value;
    return value;
  };
}

// TODO: technically this should accept AnyFunction but it doesn't type check currently with that for some reason
function memoize(func) {
  return memoizeWith(identity, func);
}

function memoizeOne(fn) {
  var called = false;
  var memoized;
  var cacheKey;
  return function () {
    if (called && (arguments.length <= 0 ? undefined : arguments[0]) === cacheKey) {
      return memoized;
    }

    called = true;
    cacheKey = arguments.length <= 0 ? undefined : arguments[0];
    memoized = fn.apply(void 0, arguments);
    return memoized;
  };
}

function noop() {}

function values(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function numericSortBy(propOrMapper, collection) {
  var mapper = typeof propOrMapper === 'function' ? propOrMapper : function (element) {
    return get(propOrMapper, element);
  };
  return (isArray(collection) ? [].concat(collection) : values(collection)).sort(function (elementA, elementB) {
    return mapper(elementA) - mapper(elementB);
  });
}

function omitByIndexed(predicate, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (!predicate(obj[key], key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function omit(keys, obj) {
  return omitByIndexed(function (value, key) {
    return keys.indexOf(key) !== -1;
  }, obj);
}

function omitBy(predicate, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (!predicate(obj[key])) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function once(fn) {
  var called = false;
  var result;
  return function () {
    if (called) {
      return result;
    }

    called = true;
    return result = fn.apply(void 0, arguments);
  };
}

function over(fns) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return fns.map(function (fn) {
      return fn.apply(void 0, args);
    });
  };
}

function takeLast(count, arr) {
  return arr.slice(-count);
}

function overArgs(fn, transformers) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var transformed = transformers.map(function (transform, index) {
      return transform(args[index]);
    });
    return args.length > transformed.length ? fn.apply(void 0, transformed.concat(takeLast(args.length - transformed.length, args))) : fn.apply(void 0, transformed);
  };
}

function partitionObject(predicate, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    acc[predicate(obj[key]) ? 0 : 1][key] = obj[key];
    return acc;
  }, [{}, {}]);
}

function pick(props, obj) {
  return props.reduce(function (acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
}

function pickBy(predicate, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (predicate(obj[key])) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function pickByIndexed(predicate, obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (predicate(obj[key], key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function pickOwn(props, obj) {
  return props.reduce(function (acc, prop) {
    if (hasOwn(prop, obj)) {
      acc[prop] = obj[prop];
    }

    return acc;
  }, {});
}

function range(max) {
  var arr = [];
  var counter = 0;

  while (counter <= max) {
    arr.push(counter++);
  }

  return arr;
}

function reject(predicate, arr) {
  return arr.filter(function (element) {
    return !predicate(element);
  });
}

function removeAt(index, arr) {
  var copy = [].concat(arr);
  copy.splice(index, 1);
  return copy;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function set$1(_keys, val, obj) {
  var _extends2;

  var keys = _keys.split ? _keys.split('.') : _keys;
  var index = keys[0];
  var finalVal = val;

  if (keys.length > 1) {
    // eslint-disable-next-line eqeqeq
    var nextObj = obj != null && hasOwn(index, obj) ? obj[index] : {};
    finalVal = set$1(keys.slice(1), val, nextObj);
  }

  return _extends({}, obj, (_extends2 = {}, _extends2[index] = finalVal, _extends2));
}

// https://github.com/reactjs/react-redux/blob/5d792a283554cff3d2f54fad1be1f79cbcab33fe/src/utils/shallowEqual.js

function is(first, second) {
  if (first === second) {
    return first !== 0 || second !== 0 || 1 / first === 1 / second;
  } // eslint-disable-next-line no-self-compare


  return first !== first && second !== second;
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var index = 0; index < keysA.length; index++) {
    if (!hasOwn(keysA[index], objB) || !is(objA[keysA[index]], objB[keysA[index]])) {
      return false;
    }
  }

  return true;
}

function sliceDiff(slice, obj) {
  var picked = pickByIndexed(function (value, key) {
    return value !== obj[key];
  }, slice);
  return isEmpty(picked) ? null : picked;
}

// TODO: this could be written a lot better
function snakeCase(str) {
  var snakeCased = str.replace(/[A-Z]|([\-_ ]+)/g, function (match) {
    var code = match.charCodeAt(0);
    var upperCased = code > 64 && code < 91;
    return upperCased ? "_" + match.toLowerCase() : '_';
  });
  return snakeCased[0] === '_' ? snakeCased.substr(1) : snakeCased;
}

function someAreTruthy(arr) {
  return arr.some(identity);
}

function splitAt(splitPoint, arr) {
  // TODO first item from the tuple could be replaced by dropRight
  return [arr.slice(0, splitPoint), arr.slice(splitPoint, arr.length)];
}

function splitRightWhenAccum(fn, acc, arr) {
  var result = false;

  for (var index = arr.length; index > 0; index--) {
    // eslint-disable-next-line no-param-reassign
    var _fn = fn(arr[index - 1], acc);

    result = _fn[0];
    acc = _fn[1];

    if (result) {
      return splitAt(index - 1, arr);
    }
  }

  return [[], arr];
}

function spread(fn) {
  return function (args) {
    return fn.apply(void 0, args);
  };
}

function sum(numbers) {
  return numbers.reduce(add, 0);
}

function take(count, arr) {
  return arr.slice(0, count);
}

function takeRightWhileFrom(predicate, startIndex, arr) {
  var endIndex = findLastIndexFrom(function (element) {
    return !predicate(element);
  }, startIndex, arr);
  return endIndex === startIndex ? [] : arr.slice(endIndex + 1, startIndex + 1);
}

function throttle(ms, fn) {
  var lastCall = Date.now() - 2 * ms;
  var trailingId;

  var invoke = function invoke() {
    lastCall = Date.now();
    fn.apply(void 0, arguments);
  };

  return function () {
    var now = Date.now();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (now - lastCall >= ms) {
      invoke.apply(void 0, args);
      return;
    }

    clearTimeout(trailingId);
    trailingId = setTimeout.apply(void 0, [invoke, lastCall - now + ms].concat(args));
  };
}

var toPairs = function toPairs(obj) {
  return Object.keys(obj).map(function (key) {
    return [key, obj[key]];
  });
};

function trailingThrottle(ms, fn) {
  var lastCall = Date.now() - 2 * ms;
  var trailingId;

  var invoke = function invoke() {
    lastCall = Date.now();
    return fn.apply(void 0, arguments);
  };

  return function () {
    var now = Date.now();

    if (now - lastCall >= ms) {
      lastCall = Date.now();
    }

    clearTimeout(trailingId);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    trailingId = setTimeout.apply(void 0, [invoke, lastCall - now + ms].concat(args));
  };
}

var leadingWhiteSpace = /^\s+/;
function trimStart(str) {
  return str.replace(leadingWhiteSpace, '');
}

var trailingWhiteSpace = /\s+$/;
function trimEnd(str) {
  return str.replace(trailingWhiteSpace, '');
}

function repeat(count, text) {
  return Array(count + 1).join(text);
}

function uniqBy(iteratee, arr) {
  // with polyfills this could be just: return Array.from(new Set(arr.map(iteratee)))
  var seen = [];
  return arr.filter(function (element) {
    var key = iteratee(element);

    if (seen.indexOf(key) === -1) {
      seen.push(key);
      return true;
    }

    return false;
  });
}

function uniq(arr) {
  return uniqBy(identity, arr);
}

function update(index, newElement, arr) {
  return [].concat(arr.slice(0, index), [newElement], arr.slice(index + 1, arr.length));
}

function without(removed, arr) {
  return arr.filter(function (element) {
    return removed.indexOf(element) === -1;
  });
}

function zipWith(zipper, arrayA, arrayB) {
  return arrayA.map(function (elementA, index) {
    return zipper(elementA, arrayB[index]);
  });
}

exports.add = add;
exports.assign = assign;
exports.chain = chain;
exports.cloneDeep = cloneDeep;
exports.camelCase = camelCase;
exports.compact = compact;
exports.compose = compose;
exports.debounce = debounce;
exports.defaultTo = defaultTo;
exports.drop = drop;
exports.dropRight = dropRight;
exports.ensureArray = ensureArray;
exports.find = find;
exports.findIndex = findIndex;
exports.findKey = findKey;
exports.findLast = findLast;
exports.findLastIndex = findLastIndex;
exports.findLastIndexFrom = findLastIndexFrom;
exports.filledArray = filledArray;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.forOwn = forOwn;
exports.fromPairs = fromPairs;
exports.generateRandomId = generateRandomId;
exports.generateUniqueId = generateUniqueId;
exports.get = get;
exports.getOr = getOr;
exports.groupBy = groupBy;
exports.groupKeys = groupKeys;
exports.hasOwn = hasOwn;
exports.identity = identity;
exports.includes = includes;
exports.isArray = isArray;
exports.isEmpty = isEmpty;
exports.isFalsy = isFalsy;
exports.isNil = isNil;
exports.isObject = isObject;
exports.isTruthy = isTruthy;
exports.isPromise = isPromise;
exports.keyBy = keyBy;
exports.last = last;
exports.mapKeys = mapKeys;
exports.mapValues = mapValues;
exports.mapValuesIndexed = mapValuesIndexed;
exports.merge = merge;
exports.mergeAll = mergeAll;
exports.memoize = memoize;
exports.memoizeOne = memoizeOne;
exports.memoizeWith = memoizeWith;
exports.noop = noop;
exports.numericSortBy = numericSortBy;
exports.omit = omit;
exports.omitBy = omitBy;
exports.omitByIndexed = omitByIndexed;
exports.once = once;
exports.over = over;
exports.overArgs = overArgs;
exports.partitionObject = partitionObject;
exports.pick = pick;
exports.pickBy = pickBy;
exports.pickByIndexed = pickByIndexed;
exports.pickOwn = pickOwn;
exports.range = range;
exports.reject = reject;
exports.removeAt = removeAt;
exports.set = set$1;
exports.shallowEqual = shallowEqual;
exports.sliceDiff = sliceDiff;
exports.snakeCase = snakeCase;
exports.someAreTruthy = someAreTruthy;
exports.splitAt = splitAt;
exports.splitRightWhenAccum = splitRightWhenAccum;
exports.spread = spread;
exports.sum = sum;
exports.take = take;
exports.takeLast = takeLast;
exports.takeRightWhileFrom = takeRightWhileFrom;
exports.throttle = throttle;
exports.toPairs = toPairs;
exports.trailingThrottle = trailingThrottle;
exports.trimStart = trimStart;
exports.trimEnd = trimEnd;
exports.repeat = repeat;
exports.uniq = uniq;
exports.uniqBy = uniqBy;
exports.update = update;
exports.values = values;
exports.without = without;
exports.zipWith = zipWith;
